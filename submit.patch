diff --git a/kern/arch/mips/conf/ldscript b/kern/arch/mips/conf/ldscript
index cbe86ac..ba44f70 100644
--- a/kern/arch/mips/conf/ldscript
+++ b/kern/arch/mips/conf/ldscript
@@ -1,3 +1,4 @@
+
 /*
  * This is a pile of crap that tells the linker how to link the kernel,
  * because it's too stupid to be able to work it out on its own.
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..e5e9cac 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -110,7 +110,10 @@ syscall(struct trapframe *tf)
 		break;
 
 	    /* Add stuff here */
- 
+	    case SYS_getpid:
+		err = sys___getpid(&retval);
+		break;
+
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
 		err = ENOSYS;
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..6b02b02 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -367,6 +367,7 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
+file      syscall/psyscall.c
 
 #
 # Startup and initialization
diff --git a/kern/include/psyscall.h b/kern/include/psyscall.h
new file mode 100644
index 0000000..b72c95d
--- /dev/null
+++ b/kern/include/psyscall.h
@@ -0,0 +1,67 @@
+#ifndef _PSYSCALL_H_
+#define _PSYSCALL_H_
+
+#include <types.h>
+#include <thread.h>
+#include <limits.h>
+
+struct trapframe;
+struct thread;
+
+/**
+ * Declared array for pid tracking
+ */
+	 int32_t global_pidarray[PID_MAX];
+
+int
+sys___getpid(int32_t *retval);
+
+
+void
+allocate_pid(pid_t *);
+
+void
+deallocate_pid(void);
+
+struct lock *pid_lock;
+
+void
+create_pidlock(void);
+
+
+/**
+ * Structure for Process Control
+ */
+struct process_control{
+	/* process pid */
+	pid_t process_id;
+	pid_t parent_id;
+
+	//Child Process
+	struct child_process *childlist;
+
+	bool exit_status;
+	int exit_code;
+
+};
+
+struct child_process{
+	pid_t child_pid;
+	struct child_process *next;
+};
+
+
+
+/*
+ * Functions for waitpid
+ */
+//waitpid(pid_t pid, int *status, int options);
+
+
+/*
+ * Fork syscall
+ */
+//int sys___fork(pid_t  *returnval, struct trapframe *tf);
+
+
+#endif /* _PSYSCALL_H_ */
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..8a53033 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -29,7 +29,7 @@
 
 #ifndef _SYNCH_H_
 #define _SYNCH_H_
-
+#define MAX_READ 500
 /*
  * Header file for synchronization primitives.
  */
@@ -74,6 +74,10 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
+        struct wchan *lock_wchan;
+        volatile int lock_hold;
+        struct spinlock lk_spinlock;
+        struct thread *lk_thread;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
+        struct wchan *cv_wchan;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -143,6 +148,10 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 
 struct rwlock {
         char *rwlock_name;
+        struct semaphore *rwlock_semaphore;
+        //struct wchan *rw_wchan;
+        //bool writer_inside;
+        struct lock *rwlock_lock;
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..ed6f24a 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -30,6 +30,7 @@
 #ifndef _SYSCALL_H_
 #define _SYSCALL_H_
 
+#include <psyscall.h>
 
 struct trapframe; /* from <machine/trapframe.h> */
 
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..4011cf6 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,6 +38,15 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
+#include <limits.h>
+/**
+ * Author: Pratham Malik
+ * included psyscalls.h and declared the process structure
+ */
+#include <psyscall.h>
+
+struct process_control;
+//End of Additions by Pratham Malik
 
 struct addrspace;
 struct cpu;
@@ -65,6 +74,8 @@ typedef enum {
 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
 } threadstate_t;
 
+
+
 /* Thread structure. */
 struct thread {
 	/*
@@ -112,6 +123,13 @@ struct thread {
 	struct vnode *t_cwd;		/* current working directory */
 
 	/* add more here as needed */
+	/*
+	 * Author: Pratham Malik
+	 * Added Process structure
+	 */
+	struct process_control *t_pcb;
+
+//	struct file_descriptor file_table[__OPEN_MAX];
 };
 
 /* Call once during system startup to allocate data structures. */
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..68723b7 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -30,6 +30,7 @@
 /*
  * Main.
  */
+// "Adding for git" marora3@buffalo.edu
 
 #include <types.h>
 #include <kern/errno.h>
@@ -50,11 +51,10 @@
 #include <version.h>
 #include "autoconf.h"  // for pseudoconfig
 
-
 /*
  * These two pieces of data are maintained by the makefiles and build system.
  * buildconfig is the name of the config file the kernel was configured with.
- * buildversion starts at 1 and is incremented every time you link a kernel. 
+ * buildversion starts at 1 and is incremented every time you link a kernel.
  *
  * The purpose is not to show off how many kernels you've linked, but
  * to make it easy to make sure that the kernel you just booted is the
@@ -100,16 +100,19 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+	kprintf("prathamm@buffalo.edu's system version %s (%s #%d)\n",
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
+
 	/* Early initialization. */
 	ram_bootstrap();
 	thread_bootstrap();
 	hardclock_bootstrap();
 	vfs_bootstrap();
 
+
+
 	/* Probe and initialize devices. Interrupts should come on. */
 	kprintf("Device probe...\n");
 	KASSERT(curthread->t_curspl > 0);
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..ccf4ee2 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -46,15 +46,42 @@
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
+struct cv *cv_male;
+struct cv *cv_female;
+struct cv *cv_matchmaker;
+
+
+static volatile int male_count,female_count,matchmaker_count;
+struct lock *matching_lock;
+
+
 
 void whalemating_init() {
-  return;
+  /*
+   * Author: Student
+   * Declaring semaphores for male,female and matchmaker
+   *
+   */
+	cv_male= cv_create("male");
+	cv_female=cv_create("female");
+	cv_matchmaker=cv_create("matchmaker");
+	matching_lock= lock_create("matching_lock");
+	male_count=0;
+	female_count=0;
+	matchmaker_count=0;
+
+	return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
+
+	cv_destroy(cv_male);
+	cv_destroy(cv_female);
+	cv_destroy(cv_matchmaker);
+	lock_destroy(matching_lock);
   return;
 }
 
@@ -62,11 +89,53 @@ void
 male(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
-  (void)which;
-  
-  male_start();
-	// Implement this function 
-  male_end();
+	(void)which;
+
+
+	  male_start();
+	  lock_acquire(matching_lock);
+	  male_count++;
+
+	  if(female_count==0 || matchmaker_count ==0){
+		  cv_wait(cv_male, matching_lock);
+		  male_end();
+	  }
+	  else if(female_count>0 && matchmaker_count >0){
+		 while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
+		 		  if(cv_male->cv_wchan != NULL){
+		 			 cv_signal(cv_male, matching_lock);
+		 			 male_count--;
+		 			 cv_signal(cv_female, matching_lock);
+		 			 cv_signal(cv_matchmaker, matching_lock);
+
+		 		  }
+		 		  else{
+		 			 cv_signal(cv_female, matching_lock);
+		 			 cv_signal(cv_matchmaker, matching_lock);
+		 			 male_count--;
+		 		  }
+
+		 		  male_end();
+
+		 	  }
+	  }
+
+
+
+	  lock_release(matching_lock);
+
+
+
+	// Implement this function
+  /*
+   * Author: Student
+   * Implementing the semaphore for male
+   */
+
+
+//male_end();
+
+
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
@@ -79,11 +148,42 @@ female(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
+
   female_start();
-	// Implement this function 
-  female_end();
-  
+
+  lock_acquire(matching_lock);
+  	  female_count++;
+  	  if(male_count ==0 || matchmaker_count== 0){
+  		  cv_wait(cv_female, matching_lock);
+  		female_end();
+  	  }
+  	  else if(male_count>0 && matchmaker_count >0){
+  		while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
+  		  		  if(cv_female->cv_wchan!= NULL){
+  		  			  cv_signal(cv_male, matching_lock);
+  		  			  male_count--;
+  		  			  cv_signal(cv_female, matching_lock);
+  		  			  female_count--;
+  		  			  cv_signal(cv_matchmaker, matching_lock);
+  		  			  matchmaker_count--;
+
+  		  		  }
+  		  		  else{
+  		  			  cv_signal(cv_male, matching_lock);
+  		  			  male_count--;
+  		  			  cv_signal(cv_matchmaker, matching_lock);
+  		  			  matchmaker_count--;
+  		  			  female_count--;
+  		  		  }
+
+  		  		female_end();
+
+  		  	  }
+  	  }
+
+
+  	  lock_release(matching_lock);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
@@ -95,17 +195,50 @@ matchmaker(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
+
   matchmaker_start();
-	// Implement this function 
-  matchmaker_end();
-  
+  lock_acquire(matching_lock);
+  	  matchmaker_count++;
+    	  if(male_count ==0 || female_count==0){
+    		  cv_wait(cv_matchmaker, matching_lock);
+    		  matchmaker_end();
+    	  }
+    	  else if(male_count>0 && female_count >0){
+    		  while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
+    		      if(cv_matchmaker->cv_wchan!= NULL){
+    		         cv_signal(cv_male, matching_lock);
+    		         male_count--;
+    		         cv_signal(cv_female, matching_lock);
+    		         female_count--;
+    		         cv_signal(cv_matchmaker, matching_lock);
+    		         matchmaker_count--;
+
+    		      }
+    		      else{
+    		        cv_signal(cv_male, matching_lock);
+    		        male_count--;
+    		        cv_signal(cv_female, matching_lock);
+    		        female_count--;
+    		      	matchmaker_count--;
+    		      }
+
+        		  matchmaker_end();
+    		  }
+    	  }
+
+
+    	  lock_release(matching_lock);
+  //matchmaker_end();
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
   return;
 }
 
+
+
+
 /*
  * You should implement your solution to the stoplight problem below. The
  * quadrant and direction mappings for reference: (although the problem is,
@@ -137,7 +270,22 @@ matchmaker(void *p, unsigned long which)
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+struct cv * cross_intersection;
+struct lock * lock_intersection;
+bool status_busy;
+static volatile int quadrant[4];	//To signify which parts of the quadrant one is occupying, 0 signifies free and 1 signifies taken
+
 void stoplight_init() {
+
+	cross_intersection= cv_create("cross0");
+
+
+	lock_intersection= lock_create("intersection_lock");
+	status_busy=false;
+	quadrant[0]=0;
+	quadrant[1]=0;
+	quadrant[2]=0;
+	quadrant[3]=0;
   return;
 }
 
@@ -145,6 +293,9 @@ void stoplight_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
+	cv_destroy(cross_intersection);
+
+	lock_destroy(lock_intersection);
   return;
 }
 
@@ -153,7 +304,35 @@ gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
+  /*
+   * Author: Student
+   */
   
+  lock_acquire(lock_intersection);
+
+  while(!(quadrant[direction]==0 && (quadrant[(direction+3)%4]==0))){
+	  cv_wait(cross_intersection,lock_intersection);
+
+  }//End of while
+
+  quadrant[direction]=1;
+  quadrant[(direction+3)%4]=1;
+
+  lock_release(lock_intersection);
+
+  inQuadrant(direction);
+  inQuadrant((direction+3)%4);
+  leaveIntersection();
+
+  lock_acquire(lock_intersection);
+  quadrant[direction]=0;
+  quadrant[(direction+3)%4]=0;
+
+	cv_signal(cross_intersection,lock_intersection);
+
+  lock_release(lock_intersection);
+
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -165,6 +344,37 @@ turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
+
+  /*
+   *  Author: Student
+     */
+
+  lock_acquire(lock_intersection);
+  while(!(quadrant[direction]==0 && (quadrant[(direction+3)%4]==0)&& (quadrant[(direction+2)%4]==0))){
+	  cv_wait(cross_intersection,lock_intersection);
+  }//End of while
+
+  quadrant[direction]=1;
+  quadrant[(direction+3)%4]=1;
+  quadrant[(direction+2)%4]=1;
+
+  lock_release(lock_intersection);
+
+  inQuadrant(direction);
+  inQuadrant((direction+3)%4);
+  inQuadrant((direction+2)%4);
+  leaveIntersection();
+
+  lock_acquire(lock_intersection);
+  quadrant[direction]=0;
+  quadrant[(direction+3)%4]=0;
+  quadrant[(direction+2)%4]=0;
+
+	cv_signal(cross_intersection,lock_intersection);
+
+  lock_release(lock_intersection);
+
+
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
@@ -180,6 +390,31 @@ turnright(void *p, unsigned long direction)
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
+
+  /*
+   *  Author: Student
+     */
+
+  lock_acquire(lock_intersection);
+
+  while(!(quadrant[direction]==0)){
+	  cv_wait(cross_intersection,lock_intersection);
+  }//End of while
+
+  quadrant[direction]=1;
+
+  lock_release(lock_intersection);
+
+  inQuadrant(direction);
+  leaveIntersection();
+
+  lock_acquire(lock_intersection);
+  quadrant[direction]=0;
+
+	cv_signal(cross_intersection,lock_intersection);
+
+  lock_release(lock_intersection);
+
   V(stoplightMenuSemaphore);
   return;
 }
diff --git a/kern/syscall/psyscall.c b/kern/syscall/psyscall.c
new file mode 100644
index 0000000..5583e05
--- /dev/null
+++ b/kern/syscall/psyscall.c
@@ -0,0 +1,95 @@
+
+#include <types.h>
+#include <clock.h>
+#include <copyinout.h>
+#include <lib.h>
+#include <thread.h>
+#include <limits.h>
+#include <current.h>
+#include <synch.h>
+
+//#include <psyscall.h>
+/*
+ * Fork System Call:: Forks a new process
+ * Returns two values to child and Parent.
+
+
+int
+sys___fork(pid_t  *returnval, struct trapframe *tf)
+{
+	struct trapframe *child_trapframe;
+	child_trapframe = tf;
+
+
+	return returnval;
+}
+*/
+/**
+ * Function for allocation pid from global array of
+ * process id
+ * 1 : Signifies that index location is taken
+ * Never initialize the array index at 1
+ */
+
+void
+allocate_pid(pid_t *processid)
+{
+//Take lock before allocating the pid
+	lock_acquire(pid_lock);
+
+	for(int32_t i=PID_MIN;i<PID_MAX;i++)
+	{
+		if(global_pidarray[i]==0){
+			global_pidarray[i]=1;
+			curthread->t_pcb->process_id=i;
+			curthread->t_pcb->parent_id=-1;
+		//	curthread->t_pcb->childlist;
+			break;
+		}
+	}
+
+	lock_release(pid_lock);
+
+}
+
+void
+deallocate_pid(void)
+{
+lock_acquire(pid_lock);
+
+pid_t processid=curthread->t_pcb->process_id;
+
+	for(int32_t i=PID_MIN;i<PID_MAX;i++)
+	{
+		if(global_pidarray[i]==processid)
+		{
+			global_pidarray[i]=0;
+			break;
+		}
+
+	}
+
+lock_release(pid_lock);
+}
+
+
+int
+sys___getpid(int32_t *retval)
+{
+	*retval = curthread->t_pcb->parent_id;
+	return 0;
+
+}
+
+
+
+/**
+ * Create lock for the pid allocation
+*/
+
+
+void
+create_pidlock(void)
+{
+	pid_lock = lock_create("pid_lock");
+}
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..f27b083 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -40,6 +40,7 @@
 #include <current.h>
 #include <synch.h>
 
+
 ////////////////////////////////////////////////////////////
 //
 // Semaphore.
@@ -87,8 +88,7 @@ sem_destroy(struct semaphore *sem)
         kfree(sem);
 }
 
-void 
-P(struct semaphore *sem)
+void P(struct semaphore *sem)
 {
         KASSERT(sem != NULL);
 
@@ -150,6 +150,9 @@ V(struct semaphore *sem)
 struct lock *
 lock_create(const char *name)
 {
+
+	DEBUG(DB_THREADS,
+							      "Inside Lock_create");
         struct lock *lock;
 
         lock = kmalloc(sizeof(struct lock));
@@ -164,7 +167,18 @@ lock_create(const char *name)
         }
         
         // add stuff here as needed
-        
+        lock->lock_wchan = wchan_create(lock->lk_name);
+        	if (lock->lock_wchan == NULL) {
+        		kfree(lock->lk_name);
+        		kfree(lock);
+        		return NULL;
+        	}
+        spinlock_init(&lock->lk_spinlock);
+        lock->lock_hold=0;
+        lock->lk_thread= NULL;
+
+        DEBUG(DB_THREADS,
+        				"Exiting lock_create");
         return lock;
 }
 
@@ -174,7 +188,8 @@ lock_destroy(struct lock *lock)
         KASSERT(lock != NULL);
 
         // add stuff here as needed
-        
+        wchan_destroy(lock->lock_wchan);
+        spinlock_cleanup(&lock->lk_spinlock);
         kfree(lock->lk_name);
         kfree(lock);
 }
@@ -183,26 +198,81 @@ void
 lock_acquire(struct lock *lock)
 {
         // Write this
+	DEBUG(DB_THREADS,
+	        				"Inside lock_acquire");
+	struct thread *mythread;
+	KASSERT(lock != NULL);
+    KASSERT(curthread->t_in_interrupt == false);
+
+	spinlock_acquire(&lock->lk_spinlock);
+
+	while(lock->lock_hold==1){
+		wchan_lock(lock->lock_wchan);
+		spinlock_release(&lock->lk_spinlock);
+		wchan_sleep(lock->lock_wchan);
+		spinlock_acquire(&lock->lk_spinlock);
+	}
+/*	else if(lock->lock_hold==0){
+		if (CURCPU_EXISTS()) {
+				mythread = curthread;
+				if (lock->lk_thread == mythread) {
+					panic("Deadlock on thread %p\n", lock);
+				}
+			}
+			else {
+				mythread = NULL;
+			} */
+
+	if(curthread!= NULL){
+				 mythread = curthread;
+				 lock->lk_thread = mythread;
+	}
+	lock->lock_hold= 1;
+
+	spinlock_release(&lock->lk_spinlock);
 
-        (void)lock;  // suppress warning until code gets written
+	  //KASSERT(lock->lock_count > 0);
+
+       //(void)lock;  // suppress warning until code gets written
+	DEBUG(DB_THREADS,
+	        				"Exiting lock_acquire");
 }
 
 void
 lock_release(struct lock *lock)
 {
         // Write this
+    KASSERT(lock != NULL);
+    spinlock_acquire(&lock->lk_spinlock);
+
+    lock->lock_hold=0;
+    KASSERT(lock->lock_hold== 0);
+    lock->lk_thread= NULL;
+    wchan_wakeone(lock->lock_wchan);
 
-        (void)lock;  // suppress warning until code gets written
+    spinlock_release(&lock->lk_spinlock);
+       // (void)lock;  // suppress warning until code gets written
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
-
-        return true; // dummy until code gets written
+	if (!CURCPU_EXISTS()) {
+			return true;
+		}
+//	if(lock->lk_holder== curcpu->c_self){
+//		return true;
+//	}
+	//KASSERT(lock->lk_thread != NULL);
+	//KASSERT(lock != NULL);
+	bool value= false;
+
+        //(void)lock;  // suppress warning until code gets written
+	spinlock_acquire(&lock->lk_spinlock);
+        value= (lock->lk_thread== curthread); // dummy until code gets written
+        spinlock_release(&lock->lk_spinlock);
+        return value;
 }
 
 ////////////////////////////////////////////////////////////
@@ -227,7 +297,20 @@ cv_create(const char *name)
         }
         
         // add stuff here as needed
-        
+        /*
+         * @Author: Student
+         * Implementing Condition Variable by defining the name
+         * and initializing the wait channel
+         */
+
+        cv->cv_wchan= wchan_create(cv->cv_name);
+		if (cv->cv_wchan == NULL) {
+			kfree(cv->cv_name);
+			kfree(cv);
+			return NULL;
+		}
+
+
         return cv;
 }
 
@@ -246,22 +329,147 @@ void
 cv_wait(struct cv *cv, struct lock *lock)
 {
         // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+//        (void)cv;    // suppress warning until code gets written
+  //      (void)lock;  // suppress warning until code gets written
+
+        /*
+         * Author: Student
+         */
+        if(lock_do_i_hold(lock)) {
+        
+		wchan_lock(cv->cv_wchan);
+		//Release the supplied lock
+		lock_release(lock);
+			wchan_sleep(cv->cv_wchan);
+
+		lock_acquire(lock);
+				
+        }
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
         // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+//	(void)cv;    // suppress warning until code gets written
+//	(void)lock;  // suppress warning until code gets written
+
+	/*
+	 * Author: Student
+	 * Wake up the wchan which is sleeping on the CV
+	 */
+	if(lock_do_i_hold(lock))
+	{
+		wchan_wakeone(cv->cv_wchan);
+	}
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+//	(void)cv;    // suppress warning until code gets written
+//	(void)lock;  // suppress warning until code gets written
+	if(lock_do_i_hold(lock)) {
+	wchan_wakeall(cv->cv_wchan);
+	}
 }
+///////////////////////////////////////////////
+//RW Locks
+
+
+struct rwlock *
+rwlock_create(const char *name)
+{
+	struct rwlock *rw;
+
+	rw = kmalloc(sizeof(rw));
+	if(rw==NULL){
+		return NULL;
+	}
+
+	rw->rwlock_name=kstrdup(name);
+	if(rw->rwlock_name==NULL){
+		kfree(rw);
+		return NULL;
+	}
+
+
+	//Create Semaphore
+	rw->rwlock_semaphore = sem_create(rw->rwlock_name,MAX_READ);
+	if (rw->rwlock_semaphore == NULL) {
+			kfree(rw->rwlock_name);
+			kfree(rw);
+			return NULL;
+	}
+	//rw->read_count=0;
+	//Create Lock
+	rw->rwlock_lock=lock_create(rw->rwlock_name);
+   	if (rw->rwlock_lock == NULL) {
+   		kfree(rw->rwlock_name);
+   		kfree(rw);
+	    return NULL;
+	}
+
+	return rw;
+}
+
+void
+rwlock_destroy(struct rwlock *rw_lock)
+{
+	KASSERT(rw_lock != NULL);
+
+	        // add stuff here as needed
+		sem_destroy(rw_lock->rwlock_semaphore);
+		lock_destroy(rw_lock->rwlock_lock);
+	    kfree(rw_lock->rwlock_name);
+	    kfree(rw_lock);
+}
+void
+rwlock_acquire_read(struct rwlock *rw_lock)
+{
+	lock_acquire(rw_lock->rwlock_lock);
+
+	P(rw_lock->rwlock_semaphore);
+	//rw_lock->read_count++;
+
+	lock_release(rw_lock->rwlock_lock);
+}
+
+void
+rwlock_release_read(struct rwlock *rw_lock){
+
+	V(rw_lock->rwlock_semaphore);
+	//rw_lock->read_count--;
+}
+
+void
+rwlock_acquire_write(struct rwlock *rw_lock){
+
+	lock_acquire(rw_lock->rwlock_lock);
+
+	while(1)
+	{
+		if(rw_lock->rwlock_semaphore->sem_count!=MAX_READ)
+			continue;
+		else if(rw_lock->rwlock_semaphore->sem_count==MAX_READ)
+		{
+			rw_lock->rwlock_semaphore->sem_count=1;
+			P(rw_lock->rwlock_semaphore);
+			break;
+		}
+	}
+
+	lock_release(rw_lock->rwlock_lock);
+}
+
+void
+rwlock_release_write(struct rwlock *rw_lock){
+
+	rw_lock->rwlock_semaphore->sem_count=MAX_READ-1;
+	V(rw_lock->rwlock_semaphore);
+
+
+}
+
+
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..d24b03a 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -48,6 +48,15 @@
 #include <mainbus.h>
 #include <vnode.h>
 
+
+/*
+ * Author: Pratham Malik
+ * Added header file for process syscalls
+ */
+#include <psyscall.h>
+#include <limits.h>
+//End of adding by Pratham Malik
+
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
 
@@ -118,6 +127,8 @@ struct thread *
 thread_create(const char *name)
 {
 	struct thread *thread;
+//Added by Pratham Malik
+	pid_t processid;
 
 	DEBUGASSERT(name != NULL);
 
@@ -154,6 +165,18 @@ thread_create(const char *name)
 
 	/* If you add to struct thread, be sure to initialize here */
 
+	/**
+	 * Author: Pratham Malik
+	 * Initialize the process control block to null
+	 */
+	thread->t_pcb = NULL;
+
+
+	allocate_pid(&processid);
+
+
+	//End of Additions by Pratham Malik
+
 	return thread;
 }
 
@@ -168,6 +191,8 @@ thread_create(const char *name)
 struct cpu *
 cpu_create(unsigned hardware_number)
 {
+	DEBUG(DB_THREADS,
+					      "Inside cpu_create");
 	struct cpu *c;
 	int result;
 	char namebuf[16];
@@ -223,6 +248,9 @@ cpu_create(unsigned hardware_number)
 
 	cpu_machdep_init(c);
 
+	DEBUG(DB_THREADS,
+					      "Leaving cpu_create");
+
 	return c;
 }
 
@@ -293,6 +321,8 @@ exorcise(void)
 void
 thread_panic(void)
 {
+	DEBUG(DB_THREADS,
+					      "Inside thread_panic");
 	/*
 	 * Kill off other CPUs.
 	 *
@@ -327,6 +357,8 @@ thread_panic(void)
 	 * might be needed. It may also be necessary to go through and
 	 * forcibly unlock all locks or the like...
 	 */
+	DEBUG(DB_THREADS,
+						      "Exiting thread_panic");
 }
 
 /*
@@ -382,6 +414,14 @@ thread_bootstrap(void)
 	curcpu->c_curthread = curthread;
 
 	/* Done */
+	/*
+		 * Author:Pratham Malik
+		 * Initializing the global variable - PID ARRAY
+		 */
+		// Call function to initialize the pidlock
+		create_pidlock();
+		//End of Addition by Pratham Malik
+
 }
 
 /*
@@ -436,6 +476,7 @@ static
 void
 thread_make_runnable(struct thread *target, bool already_have_lock)
 {
+
 	struct cpu *targetcpu;
 	bool isidle;
 
@@ -1070,7 +1111,8 @@ wchan_wakeone(struct wchan *wc)
 		/* Nobody was sleeping. */
 		return;
 	}
-
+	DEBUG(DB_THREADS,
+				      "Waking thread UP");
 	thread_make_runnable(target, false);
 }
 
@@ -1108,6 +1150,8 @@ wchan_wakeall(struct wchan *wc)
 		thread_make_runnable(target, false);
 	}
 
+	DEBUG(DB_THREADS,
+					      "Waking All threads UP");
 	threadlist_cleanup(&list);
 }
 
diff --git a/submit.patch b/submit.patch
new file mode 100644
index 0000000..eef4418
--- /dev/null
+++ b/submit.patch
@@ -0,0 +1,1059 @@
+diff --git a/kern/arch/mips/conf/ldscript b/kern/arch/mips/conf/ldscript
+index cbe86ac..ba44f70 100644
+--- a/kern/arch/mips/conf/ldscript
++++ b/kern/arch/mips/conf/ldscript
+@@ -1,3 +1,4 @@
++
+ /*
+  * This is a pile of crap that tells the linker how to link the kernel,
+  * because it's too stupid to be able to work it out on its own.
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..e5e9cac 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -110,7 +110,10 @@ syscall(struct trapframe *tf)
+ 		break;
+ 
+ 	    /* Add stuff here */
+- 
++	    case SYS_getpid:
++		err = sys___getpid(&retval);
++		break;
++
+ 	    default:
+ 		kprintf("Unknown syscall %d\n", callno);
+ 		err = ENOSYS;
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..6b02b02 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,7 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/psyscall.c
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/psyscall.h b/kern/include/psyscall.h
+new file mode 100644
+index 0000000..b72c95d
+--- /dev/null
++++ b/kern/include/psyscall.h
+@@ -0,0 +1,67 @@
++#ifndef _PSYSCALL_H_
++#define _PSYSCALL_H_
++
++#include <types.h>
++#include <thread.h>
++#include <limits.h>
++
++struct trapframe;
++struct thread;
++
++/**
++ * Declared array for pid tracking
++ */
++	 int32_t global_pidarray[PID_MAX];
++
++int
++sys___getpid(int32_t *retval);
++
++
++void
++allocate_pid(pid_t *);
++
++void
++deallocate_pid(void);
++
++struct lock *pid_lock;
++
++void
++create_pidlock(void);
++
++
++/**
++ * Structure for Process Control
++ */
++struct process_control{
++	/* process pid */
++	pid_t process_id;
++	pid_t parent_id;
++
++	//Child Process
++	struct child_process *childlist;
++
++	bool exit_status;
++	int exit_code;
++
++};
++
++struct child_process{
++	pid_t child_pid;
++	struct child_process *next;
++};
++
++
++
++/*
++ * Functions for waitpid
++ */
++//waitpid(pid_t pid, int *status, int options);
++
++
++/*
++ * Fork syscall
++ */
++//int sys___fork(pid_t  *returnval, struct trapframe *tf);
++
++
++#endif /* _PSYSCALL_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..8a53033 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -29,7 +29,7 @@
+ 
+ #ifndef _SYNCH_H_
+ #define _SYNCH_H_
+-
++#define MAX_READ 500
+ /*
+  * Header file for synchronization primitives.
+  */
+@@ -74,6 +74,10 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++        struct wchan *lock_wchan;
++        volatile int lock_hold;
++        struct spinlock lk_spinlock;
++        struct thread *lk_thread;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        struct wchan *cv_wchan;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -143,6 +148,10 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        struct semaphore *rwlock_semaphore;
++        //struct wchan *rw_wchan;
++        //bool writer_inside;
++        struct lock *rwlock_lock;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..ed6f24a 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -30,6 +30,7 @@
+ #ifndef _SYSCALL_H_
+ #define _SYSCALL_H_
+ 
++#include <psyscall.h>
+ 
+ struct trapframe; /* from <machine/trapframe.h> */
+ 
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..4011cf6 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -38,6 +38,15 @@
+ 
+ #include <spinlock.h>
+ #include <threadlist.h>
++#include <limits.h>
++/**
++ * Author: Pratham Malik
++ * included psyscalls.h and declared the process structure
++ */
++#include <psyscall.h>
++
++struct process_control;
++//End of Additions by Pratham Malik
+ 
+ struct addrspace;
+ struct cpu;
+@@ -65,6 +74,8 @@ typedef enum {
+ 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
+ } threadstate_t;
+ 
++
++
+ /* Thread structure. */
+ struct thread {
+ 	/*
+@@ -112,6 +123,13 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++	/*
++	 * Author: Pratham Malik
++	 * Added Process structure
++	 */
++	struct process_control *t_pcb;
++
++//	struct file_descriptor file_table[__OPEN_MAX];
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..68723b7 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -30,6 +30,7 @@
+ /*
+  * Main.
+  */
++// "Adding for git" marora3@buffalo.edu
+ 
+ #include <types.h>
+ #include <kern/errno.h>
+@@ -50,11 +51,10 @@
+ #include <version.h>
+ #include "autoconf.h"  // for pseudoconfig
+ 
+-
+ /*
+  * These two pieces of data are maintained by the makefiles and build system.
+  * buildconfig is the name of the config file the kernel was configured with.
+- * buildversion starts at 1 and is incremented every time you link a kernel. 
++ * buildversion starts at 1 and is incremented every time you link a kernel.
+  *
+  * The purpose is not to show off how many kernels you've linked, but
+  * to make it easy to make sure that the kernel you just booted is the
+@@ -100,16 +100,19 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("prathamm@buffalo.edu's system version %s (%s #%d)\n",
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
++
+ 	/* Early initialization. */
+ 	ram_bootstrap();
+ 	thread_bootstrap();
+ 	hardclock_bootstrap();
+ 	vfs_bootstrap();
+ 
++
++
+ 	/* Probe and initialize devices. Interrupts should come on. */
+ 	kprintf("Device probe...\n");
+ 	KASSERT(curthread->t_curspl > 0);
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..ccf4ee2 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -46,15 +46,42 @@
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct cv *cv_male;
++struct cv *cv_female;
++struct cv *cv_matchmaker;
++
++
++static volatile int male_count,female_count,matchmaker_count;
++struct lock *matching_lock;
++
++
+ 
+ void whalemating_init() {
+-  return;
++  /*
++   * Author: Student
++   * Declaring semaphores for male,female and matchmaker
++   *
++   */
++	cv_male= cv_create("male");
++	cv_female=cv_create("female");
++	cv_matchmaker=cv_create("matchmaker");
++	matching_lock= lock_create("matching_lock");
++	male_count=0;
++	female_count=0;
++	matchmaker_count=0;
++
++	return;
+ }
+ 
+ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++
++	cv_destroy(cv_male);
++	cv_destroy(cv_female);
++	cv_destroy(cv_matchmaker);
++	lock_destroy(matching_lock);
+   return;
+ }
+ 
+@@ -62,11 +89,53 @@ void
+ male(void *p, unsigned long which)
+ {
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+-  (void)which;
+-  
+-  male_start();
+-	// Implement this function 
+-  male_end();
++	(void)which;
++
++
++	  male_start();
++	  lock_acquire(matching_lock);
++	  male_count++;
++
++	  if(female_count==0 || matchmaker_count ==0){
++		  cv_wait(cv_male, matching_lock);
++		  male_end();
++	  }
++	  else if(female_count>0 && matchmaker_count >0){
++		 while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
++		 		  if(cv_male->cv_wchan != NULL){
++		 			 cv_signal(cv_male, matching_lock);
++		 			 male_count--;
++		 			 cv_signal(cv_female, matching_lock);
++		 			 cv_signal(cv_matchmaker, matching_lock);
++
++		 		  }
++		 		  else{
++		 			 cv_signal(cv_female, matching_lock);
++		 			 cv_signal(cv_matchmaker, matching_lock);
++		 			 male_count--;
++		 		  }
++
++		 		  male_end();
++
++		 	  }
++	  }
++
++
++
++	  lock_release(matching_lock);
++
++
++
++	// Implement this function
++  /*
++   * Author: Student
++   * Implementing the semaphore for male
++   */
++
++
++//male_end();
++
++
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+@@ -79,11 +148,42 @@ female(void *p, unsigned long which)
+ {
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+-  
++
+   female_start();
+-	// Implement this function 
+-  female_end();
+-  
++
++  lock_acquire(matching_lock);
++  	  female_count++;
++  	  if(male_count ==0 || matchmaker_count== 0){
++  		  cv_wait(cv_female, matching_lock);
++  		female_end();
++  	  }
++  	  else if(male_count>0 && matchmaker_count >0){
++  		while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
++  		  		  if(cv_female->cv_wchan!= NULL){
++  		  			  cv_signal(cv_male, matching_lock);
++  		  			  male_count--;
++  		  			  cv_signal(cv_female, matching_lock);
++  		  			  female_count--;
++  		  			  cv_signal(cv_matchmaker, matching_lock);
++  		  			  matchmaker_count--;
++
++  		  		  }
++  		  		  else{
++  		  			  cv_signal(cv_male, matching_lock);
++  		  			  male_count--;
++  		  			  cv_signal(cv_matchmaker, matching_lock);
++  		  			  matchmaker_count--;
++  		  			  female_count--;
++  		  		  }
++
++  		  		female_end();
++
++  		  	  }
++  	  }
++
++
++  	  lock_release(matching_lock);
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+@@ -95,17 +195,50 @@ matchmaker(void *p, unsigned long which)
+ {
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+-  
++
+   matchmaker_start();
+-	// Implement this function 
+-  matchmaker_end();
+-  
++  lock_acquire(matching_lock);
++  	  matchmaker_count++;
++    	  if(male_count ==0 || female_count==0){
++    		  cv_wait(cv_matchmaker, matching_lock);
++    		  matchmaker_end();
++    	  }
++    	  else if(male_count>0 && female_count >0){
++    		  while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
++    		      if(cv_matchmaker->cv_wchan!= NULL){
++    		         cv_signal(cv_male, matching_lock);
++    		         male_count--;
++    		         cv_signal(cv_female, matching_lock);
++    		         female_count--;
++    		         cv_signal(cv_matchmaker, matching_lock);
++    		         matchmaker_count--;
++
++    		      }
++    		      else{
++    		        cv_signal(cv_male, matching_lock);
++    		        male_count--;
++    		        cv_signal(cv_female, matching_lock);
++    		        female_count--;
++    		      	matchmaker_count--;
++    		      }
++
++        		  matchmaker_end();
++    		  }
++    	  }
++
++
++    	  lock_release(matching_lock);
++  //matchmaker_end();
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
++
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -137,7 +270,22 @@ matchmaker(void *p, unsigned long which)
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
+ 
++struct cv * cross_intersection;
++struct lock * lock_intersection;
++bool status_busy;
++static volatile int quadrant[4];	//To signify which parts of the quadrant one is occupying, 0 signifies free and 1 signifies taken
++
+ void stoplight_init() {
++
++	cross_intersection= cv_create("cross0");
++
++
++	lock_intersection= lock_create("intersection_lock");
++	status_busy=false;
++	quadrant[0]=0;
++	quadrant[1]=0;
++	quadrant[2]=0;
++	quadrant[3]=0;
+   return;
+ }
+ 
+@@ -145,6 +293,9 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
++	cv_destroy(cross_intersection);
++
++	lock_destroy(lock_intersection);
+   return;
+ }
+ 
+@@ -153,7 +304,35 @@ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++  /*
++   * Author: Student
++   */
+   
++  lock_acquire(lock_intersection);
++
++  while(!(quadrant[direction]==0 && (quadrant[(direction+3)%4]==0))){
++	  cv_wait(cross_intersection,lock_intersection);
++
++  }//End of while
++
++  quadrant[direction]=1;
++  quadrant[(direction+3)%4]=1;
++
++  lock_release(lock_intersection);
++
++  inQuadrant(direction);
++  inQuadrant((direction+3)%4);
++  leaveIntersection();
++
++  lock_acquire(lock_intersection);
++  quadrant[direction]=0;
++  quadrant[(direction+3)%4]=0;
++
++	cv_signal(cross_intersection,lock_intersection);
++
++  lock_release(lock_intersection);
++
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,6 +344,37 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++
++  /*
++   *  Author: Student
++     */
++
++  lock_acquire(lock_intersection);
++  while(!(quadrant[direction]==0 && (quadrant[(direction+3)%4]==0)&& (quadrant[(direction+2)%4]==0))){
++	  cv_wait(cross_intersection,lock_intersection);
++  }//End of while
++
++  quadrant[direction]=1;
++  quadrant[(direction+3)%4]=1;
++  quadrant[(direction+2)%4]=1;
++
++  lock_release(lock_intersection);
++
++  inQuadrant(direction);
++  inQuadrant((direction+3)%4);
++  inQuadrant((direction+2)%4);
++  leaveIntersection();
++
++  lock_acquire(lock_intersection);
++  quadrant[direction]=0;
++  quadrant[(direction+3)%4]=0;
++  quadrant[(direction+2)%4]=0;
++
++	cv_signal(cross_intersection,lock_intersection);
++
++  lock_release(lock_intersection);
++
++
+   
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+@@ -180,6 +390,31 @@ turnright(void *p, unsigned long direction)
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
++
++  /*
++   *  Author: Student
++     */
++
++  lock_acquire(lock_intersection);
++
++  while(!(quadrant[direction]==0)){
++	  cv_wait(cross_intersection,lock_intersection);
++  }//End of while
++
++  quadrant[direction]=1;
++
++  lock_release(lock_intersection);
++
++  inQuadrant(direction);
++  leaveIntersection();
++
++  lock_acquire(lock_intersection);
++  quadrant[direction]=0;
++
++	cv_signal(cross_intersection,lock_intersection);
++
++  lock_release(lock_intersection);
++
+   V(stoplightMenuSemaphore);
+   return;
+ }
+diff --git a/kern/syscall/psyscall.c b/kern/syscall/psyscall.c
+new file mode 100644
+index 0000000..5583e05
+--- /dev/null
++++ b/kern/syscall/psyscall.c
+@@ -0,0 +1,95 @@
++
++#include <types.h>
++#include <clock.h>
++#include <copyinout.h>
++#include <lib.h>
++#include <thread.h>
++#include <limits.h>
++#include <current.h>
++#include <synch.h>
++
++//#include <psyscall.h>
++/*
++ * Fork System Call:: Forks a new process
++ * Returns two values to child and Parent.
++
++
++int
++sys___fork(pid_t  *returnval, struct trapframe *tf)
++{
++	struct trapframe *child_trapframe;
++	child_trapframe = tf;
++
++
++	return returnval;
++}
++*/
++/**
++ * Function for allocation pid from global array of
++ * process id
++ * 1 : Signifies that index location is taken
++ * Never initialize the array index at 1
++ */
++
++void
++allocate_pid(pid_t *processid)
++{
++//Take lock before allocating the pid
++	lock_acquire(pid_lock);
++
++	for(int32_t i=PID_MIN;i<PID_MAX;i++)
++	{
++		if(global_pidarray[i]==0){
++			global_pidarray[i]=1;
++			curthread->t_pcb->process_id=i;
++			curthread->t_pcb->parent_id=-1;
++		//	curthread->t_pcb->childlist;
++			break;
++		}
++	}
++
++	lock_release(pid_lock);
++
++}
++
++void
++deallocate_pid(void)
++{
++lock_acquire(pid_lock);
++
++pid_t processid=curthread->t_pcb->process_id;
++
++	for(int32_t i=PID_MIN;i<PID_MAX;i++)
++	{
++		if(global_pidarray[i]==processid)
++		{
++			global_pidarray[i]=0;
++			break;
++		}
++
++	}
++
++lock_release(pid_lock);
++}
++
++
++int
++sys___getpid(int32_t *retval)
++{
++	*retval = curthread->t_pcb->parent_id;
++	return 0;
++
++}
++
++
++
++/**
++ * Create lock for the pid allocation
++*/
++
++
++void
++create_pidlock(void)
++{
++	pid_lock = lock_create("pid_lock");
++}
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..f27b083 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -40,6 +40,7 @@
+ #include <current.h>
+ #include <synch.h>
+ 
++
+ ////////////////////////////////////////////////////////////
+ //
+ // Semaphore.
+@@ -87,8 +88,7 @@ sem_destroy(struct semaphore *sem)
+         kfree(sem);
+ }
+ 
+-void 
+-P(struct semaphore *sem)
++void P(struct semaphore *sem)
+ {
+         KASSERT(sem != NULL);
+ 
+@@ -150,6 +150,9 @@ V(struct semaphore *sem)
+ struct lock *
+ lock_create(const char *name)
+ {
++
++	DEBUG(DB_THREADS,
++							      "Inside Lock_create");
+         struct lock *lock;
+ 
+         lock = kmalloc(sizeof(struct lock));
+@@ -164,7 +167,18 @@ lock_create(const char *name)
+         }
+         
+         // add stuff here as needed
+-        
++        lock->lock_wchan = wchan_create(lock->lk_name);
++        	if (lock->lock_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++        spinlock_init(&lock->lk_spinlock);
++        lock->lock_hold=0;
++        lock->lk_thread= NULL;
++
++        DEBUG(DB_THREADS,
++        				"Exiting lock_create");
+         return lock;
+ }
+ 
+@@ -174,7 +188,8 @@ lock_destroy(struct lock *lock)
+         KASSERT(lock != NULL);
+ 
+         // add stuff here as needed
+-        
++        wchan_destroy(lock->lock_wchan);
++        spinlock_cleanup(&lock->lk_spinlock);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +198,81 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
++	DEBUG(DB_THREADS,
++	        				"Inside lock_acquire");
++	struct thread *mythread;
++	KASSERT(lock != NULL);
++    KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->lk_spinlock);
++
++	while(lock->lock_hold==1){
++		wchan_lock(lock->lock_wchan);
++		spinlock_release(&lock->lk_spinlock);
++		wchan_sleep(lock->lock_wchan);
++		spinlock_acquire(&lock->lk_spinlock);
++	}
++/*	else if(lock->lock_hold==0){
++		if (CURCPU_EXISTS()) {
++				mythread = curthread;
++				if (lock->lk_thread == mythread) {
++					panic("Deadlock on thread %p\n", lock);
++				}
++			}
++			else {
++				mythread = NULL;
++			} */
++
++	if(curthread!= NULL){
++				 mythread = curthread;
++				 lock->lk_thread = mythread;
++	}
++	lock->lock_hold= 1;
++
++	spinlock_release(&lock->lk_spinlock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++	  //KASSERT(lock->lock_count > 0);
++
++       //(void)lock;  // suppress warning until code gets written
++	DEBUG(DB_THREADS,
++	        				"Exiting lock_acquire");
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
+         // Write this
++    KASSERT(lock != NULL);
++    spinlock_acquire(&lock->lk_spinlock);
++
++    lock->lock_hold=0;
++    KASSERT(lock->lock_hold== 0);
++    lock->lk_thread= NULL;
++    wchan_wakeone(lock->lock_wchan);
+ 
+-        (void)lock;  // suppress warning until code gets written
++    spinlock_release(&lock->lk_spinlock);
++       // (void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	if (!CURCPU_EXISTS()) {
++			return true;
++		}
++//	if(lock->lk_holder== curcpu->c_self){
++//		return true;
++//	}
++	//KASSERT(lock->lk_thread != NULL);
++	//KASSERT(lock != NULL);
++	bool value= false;
++
++        //(void)lock;  // suppress warning until code gets written
++	spinlock_acquire(&lock->lk_spinlock);
++        value= (lock->lk_thread== curthread); // dummy until code gets written
++        spinlock_release(&lock->lk_spinlock);
++        return value;
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -227,7 +297,20 @@ cv_create(const char *name)
+         }
+         
+         // add stuff here as needed
+-        
++        /*
++         * @Author: Student
++         * Implementing Condition Variable by defining the name
++         * and initializing the wait channel
++         */
++
++        cv->cv_wchan= wchan_create(cv->cv_name);
++		if (cv->cv_wchan == NULL) {
++			kfree(cv->cv_name);
++			kfree(cv);
++			return NULL;
++		}
++
++
+         return cv;
+ }
+ 
+@@ -246,22 +329,147 @@ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++//        (void)cv;    // suppress warning until code gets written
++  //      (void)lock;  // suppress warning until code gets written
++
++        /*
++         * Author: Student
++         */
++        if(lock_do_i_hold(lock)) {
++        
++		wchan_lock(cv->cv_wchan);
++		//Release the supplied lock
++		lock_release(lock);
++			wchan_sleep(cv->cv_wchan);
++
++		lock_acquire(lock);
++				
++        }
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++//	(void)cv;    // suppress warning until code gets written
++//	(void)lock;  // suppress warning until code gets written
++
++	/*
++	 * Author: Student
++	 * Wake up the wchan which is sleeping on the CV
++	 */
++	if(lock_do_i_hold(lock))
++	{
++		wchan_wakeone(cv->cv_wchan);
++	}
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++//	(void)cv;    // suppress warning until code gets written
++//	(void)lock;  // suppress warning until code gets written
++	if(lock_do_i_hold(lock)) {
++	wchan_wakeall(cv->cv_wchan);
++	}
+ }
++///////////////////////////////////////////////
++//RW Locks
++
++
++struct rwlock *
++rwlock_create(const char *name)
++{
++	struct rwlock *rw;
++
++	rw = kmalloc(sizeof(rw));
++	if(rw==NULL){
++		return NULL;
++	}
++
++	rw->rwlock_name=kstrdup(name);
++	if(rw->rwlock_name==NULL){
++		kfree(rw);
++		return NULL;
++	}
++
++
++	//Create Semaphore
++	rw->rwlock_semaphore = sem_create(rw->rwlock_name,MAX_READ);
++	if (rw->rwlock_semaphore == NULL) {
++			kfree(rw->rwlock_name);
++			kfree(rw);
++			return NULL;
++	}
++	//rw->read_count=0;
++	//Create Lock
++	rw->rwlock_lock=lock_create(rw->rwlock_name);
++   	if (rw->rwlock_lock == NULL) {
++   		kfree(rw->rwlock_name);
++   		kfree(rw);
++	    return NULL;
++	}
++
++	return rw;
++}
++
++void
++rwlock_destroy(struct rwlock *rw_lock)
++{
++	KASSERT(rw_lock != NULL);
++
++	        // add stuff here as needed
++		sem_destroy(rw_lock->rwlock_semaphore);
++		lock_destroy(rw_lock->rwlock_lock);
++	    kfree(rw_lock->rwlock_name);
++	    kfree(rw_lock);
++}
++void
++rwlock_acquire_read(struct rwlock *rw_lock)
++{
++	lock_acquire(rw_lock->rwlock_lock);
++
++	P(rw_lock->rwlock_semaphore);
++	//rw_lock->read_count++;
++
++	lock_release(rw_lock->rwlock_lock);
++}
++
++void
++rwlock_release_read(struct rwlock *rw_lock){
++
++	V(rw_lock->rwlock_semaphore);
++	//rw_lock->read_count--;
++}
++
++void
++rwlock_acquire_write(struct rwlock *rw_lock){
++
++	lock_acquire(rw_lock->rwlock_lock);
++
++	while(1)
++	{
++		if(rw_lock->rwlock_semaphore->sem_count!=MAX_READ)
++			continue;
++		else if(rw_lock->rwlock_semaphore->sem_count==MAX_READ)
++		{
++			rw_lock->rwlock_semaphore->sem_count=1;
++			P(rw_lock->rwlock_semaphore);
++			break;
++		}
++	}
++
++	lock_release(rw_lock->rwlock_lock);
++}
++
++void
++rwlock_release_write(struct rwlock *rw_lock){
++
++	rw_lock->rwlock_semaphore->sem_count=MAX_READ-1;
++	V(rw_lock->rwlock_semaphore);
++
++
++}
++
++
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..d24b03a 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -48,6 +48,15 @@
+ #include <mainbus.h>
+ #include <vnode.h>
+ 
++
++/*
++ * Author: Pratham Malik
++ * Added header file for process syscalls
++ */
++#include <psyscall.h>
++#include <limits.h>
++//End of adding by Pratham Malik
++
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
+ 
+@@ -118,6 +127,8 @@ struct thread *
+ thread_create(const char *name)
+ {
+ 	struct thread *thread;
++//Added by Pratham Malik
++	pid_t processid;
+ 
+ 	DEBUGASSERT(name != NULL);
+ 
+@@ -154,6 +165,18 @@ thread_create(c
\ No newline at end of file
diff --git a/user/lib/libc/stdlib/malloc.c b/user/lib/libc/stdlib/malloc.c
index ad0c91c..b440d5b 100644
--- a/user/lib/libc/stdlib/malloc.c
+++ b/user/lib/libc/stdlib/malloc.c
@@ -153,7 +153,7 @@ __malloc_init(void)
 	 * Check various assumed properties of the sizes.
 	 */
 	if (sizeof(struct mheader) != MBLOCKSIZE) {
-		errx(1, "malloc: Internal error - MBLOCKSIZE wrong");
+ss		errx(1, "malloc: Internal error - MBLOCKSIZE wrong");
 	}
 	if ((MBLOCKSIZE & (MBLOCKSIZE-1))!=0) {
 		errx(1, "malloc: Internal error - MBLOCKSIZE not power of 2");
