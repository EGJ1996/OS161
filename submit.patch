diff --git a/kern/arch/mips/conf/ldscript b/kern/arch/mips/conf/ldscript
index cbe86ac..ba44f70 100644
--- a/kern/arch/mips/conf/ldscript
+++ b/kern/arch/mips/conf/ldscript
@@ -1,3 +1,4 @@
+
 /*
  * This is a pile of crap that tells the linker how to link the kernel,
  * because it's too stupid to be able to work it out on its own.
diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
index ff39633..cb2b6a0 100644
--- a/kern/arch/mips/locore/trap.c
+++ b/kern/arch/mips/locore/trap.c
@@ -39,7 +39,8 @@
 #include <vm.h>
 #include <mainbus.h>
 #include <syscall.h>
-
+#include <../../../include/psyscall.h>
+#include <../../../include/kern/wait.h>
 
 /* in exception.S */
 extern void asm_usermode(struct trapframe *tf);
@@ -114,7 +115,24 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
 
 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
 		code, sig, trapcodenames[code], epc, vaddr);
-	panic("I don't know how to handle this\n");
+
+
+		sys___exit(0);
+//Added by Pratham Malik
+
+/*
+		pid_t pid_process=curthread->t_pid;
+
+		//Store the exit code passed in the argument
+		process_array[pid_process]->exit_code= 0;
+
+		//Indicate Exit by calling changing the exit status in the process array
+		process_array[pid_process]->exit_status=true;
+
+		thread_exit();
+*/
+//End of Additions by PM
+//	panic("I don't know how to handle this\n");
 }
 
 /*
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..1117b51 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -35,6 +35,7 @@
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
+#include <file_syscall.h>
 
 
 /*
@@ -80,6 +81,7 @@ syscall(struct trapframe *tf)
 {
 	int callno;
 	int32_t retval;
+	int32_t ret_value;
 	int err;
 
 	KASSERT(curthread != NULL);
@@ -96,9 +98,12 @@ syscall(struct trapframe *tf)
 	 * deal with it except for calls that return other values, 
 	 * like write.
 	 */
+//		kprintf("\nsyscall %d\n", callno);
 
 	retval = 0;
 
+	ret_value=0;
+	int64_t lseek_variable=0;
 	switch (callno) {
 	    case SYS_reboot:
 		err = sys_reboot(tf->tf_a0);
@@ -109,8 +114,71 @@ syscall(struct trapframe *tf)
 				 (userptr_t)tf->tf_a1);
 		break;
 
-	    /* Add stuff here */
+	    case SYS_open:
+	    	err= sys_open((userptr_t)tf->tf_a0,
+	    			tf->tf_a1, &retval);
+	    break;
+
+	    case SYS_close:
+	    	err= sys_close(tf->tf_a0);
+	    break;
+
+	    case SYS_read:
+	    	err= sys_read(tf->tf_a0, (userptr_t)tf->tf_a1,
+	    			tf->tf_a2, &retval);
+	    break;
+	    case SYS_write:
+	    err= sys_write(tf->tf_a0, (userptr_t)tf->tf_a1,
+	    		tf->tf_a2, &retval);
+	    break;
+
+	    case SYS_dup2:
+	    err= dup2(tf->tf_a0,tf->tf_a1, &retval);
+	    break;
+
+	    case SYS___getcwd:
+	    err= __getcwd((userptr_t)tf->tf_a0,
+	    		tf->tf_a1, &retval);
+	    break;
+
+	    case SYS_chdir:
+	    	err= chdir((userptr_t)tf->tf_a0);
+	     break;
+
+	    case SYS_lseek:
+	    	lseek_variable= (int64_t)tf->tf_a2 << 32 | tf->tf_a3;
+	    	err= lseek(tf->tf_a0, lseek_variable, tf->tf_sp+16, &retval, &ret_value);
+	    break;
+
+	    /* Add stuff
+	     *  here */
  
+
+	    /* Add stuff here */
+
+
+	    case SYS_getpid:
+		err = sys___getpid(&retval);
+		break;
+
+	    case SYS__exit:
+	    err = sys___exit(tf->tf_a0);
+	    break;
+
+	    case SYS_waitpid:
+	    err = sys___waitpid(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&retval);
+	    break;
+
+	    case SYS_fork:
+	    err = sys___fork(tf,&retval);
+	    break;
+
+
+	    case SYS_execv:
+	    err = sys___execv((userptr_t)tf->tf_a0,(userptr_t)tf->tf_a1);
+	    break;
+
+
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
 		err = ENOSYS;
@@ -130,6 +198,7 @@ syscall(struct trapframe *tf)
 	else {
 		/* Success. */
 		tf->tf_v0 = retval;
+		tf->tf_v1= ret_value;
 		tf->tf_a3 = 0;      /* signal no error */
 	}
 	
@@ -153,9 +222,10 @@ syscall(struct trapframe *tf)
  * both it and the code that calls it.
  *
  * Thus, you can trash it and do things another way if you prefer.
- */
+ *
 void
 enter_forked_process(struct trapframe *tf)
 {
 	(void)tf;
 }
+*/
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..0c1bd8c 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -367,6 +367,9 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
+file      syscall/file_syscall.c
+file      syscall/psyscall.c
+
 
 #
 # Startup and initialization
diff --git a/kern/include/file_syscall.h b/kern/include/file_syscall.h
new file mode 100644
index 0000000..80f9a94
--- /dev/null
+++ b/kern/include/file_syscall.h
@@ -0,0 +1,40 @@
+/*
+ * file_syscall.h
+ *
+ *  Created on: Mar 1, 2015
+ *      Author: trinity
+ */
+
+#ifndef FILE_SYSCALL_H_
+#define FILE_SYSCALL_H_
+
+
+struct vnode;
+struct lock;
+
+struct file_descriptor{
+	char *f_name;
+	int f_flag;
+	off_t f_offset;
+	struct lock *f_lock;
+	struct vnode *f_object;
+	int reference_count;
+};
+
+int intialize_file_desc_tbl(struct file_descriptor *file_table[]);
+struct file_descriptor* intialize_file_desc_con(struct vnode *v, int index, char *file_name, int open_type);
+struct file_descriptor* file_descriptor_init(char *name);
+void file_descriptor_cleanup(struct file_descriptor *fd);
+int sys_open(userptr_t filename, int flags, int *return_val);
+int sys_close(int fd);
+int sys_read(int fd, userptr_t buf, size_t buflen, int *return_value);
+int sys_write(int fd, userptr_t buf, size_t nbytes, int *return_value);
+int dup2(int oldfd, int newfd, int *return_value);
+int __getcwd(userptr_t buf, size_t buflen, int *return_value);
+int chdir(userptr_t pathname);
+int lseek(int fd, off_t pos, int32_t whence, int32_t *return_value1, int32_t *return_value2);
+
+
+
+
+#endif /* FILE_SYSCALL_H_ */
diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
index 3fad3f2..51a12c5 100644
--- a/kern/include/kern/limits.h
+++ b/kern/include/kern/limits.h
@@ -71,6 +71,8 @@
 /* Max bytes for atomic pipe I/O -- see description in the pipe() man page */
 #define __PIPE_BUF      512
 
+/* Max value for a processes (Maximum number of user process that can run) */
+#define __PROCESS_MAX       512
 
 /*
  * Not so important parts of the API.
diff --git a/kern/include/limits.h b/kern/include/limits.h
index 01684c4..1bc3c28 100644
--- a/kern/include/limits.h
+++ b/kern/include/limits.h
@@ -48,5 +48,10 @@
 #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
 #define OPEN_MAX        __OPEN_MAX
 #define IOV_MAX         __IOV_MAX
+/**
+ * Author Pratham Malik
+ */
+#define PROCESS_MAX         __PROCESS_MAX
+
 
 #endif /* _LIMITS_H_ */
diff --git a/kern/include/psyscall.h b/kern/include/psyscall.h
new file mode 100644
index 0000000..2dd045c
--- /dev/null
+++ b/kern/include/psyscall.h
@@ -0,0 +1,81 @@
+#ifndef _PSYSCALL_H_
+#define _PSYSCALL_H_
+
+#include <types.h>
+#include <thread.h>
+#include <limits.h>
+
+
+struct trapframe;
+struct thread;
+
+/**
+ * Declared array for pid tracking
+ */
+extern struct process_control *process_array[PROCESS_MAX];
+extern struct lock *pid_lock;
+/**
+* Structure for Process Control
+*/
+struct process_control
+{
+	/* process pid */
+
+	pid_t parent_id;
+	bool exit_status;
+	int exit_code;
+
+	struct thread *mythread;
+
+	//Child Process
+	struct child_process *childlist;
+
+	//Semaphore to synchronize the the exit status
+	struct semaphore *process_sem;
+
+	bool waitstatus;
+	struct lock *process_lock;
+	struct cv *process_cv;
+};
+
+struct child_process{
+
+	pid_t child_pid;
+	struct child_process *next;
+};
+
+/* Function to allocate pid to the thread and initialize the contents of Process structure*/
+
+pid_t
+allocate_pid(void);
+
+void
+initialize_pid(struct thread *thr,pid_t processid);
+
+int
+sys___getpid(int32_t *retval);
+
+int
+sys___exit(int);
+
+int
+sys___waitpid(int ,userptr_t ,int ,int32_t *retval);
+
+int
+sys___kwaitpid(int ,int *status,int ,int32_t *retval);
+
+
+
+void
+deallocate_pid(pid_t processid);
+
+int
+sys___fork(struct trapframe *tf,pid_t  *returnval);
+
+void
+enter_process(void *tf,unsigned long addr);
+
+int
+sys___execv(userptr_t ,userptr_t);
+
+#endif /* _PSYSCALL_H_ */
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..8a53033 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -29,7 +29,7 @@
 
 #ifndef _SYNCH_H_
 #define _SYNCH_H_
-
+#define MAX_READ 500
 /*
  * Header file for synchronization primitives.
  */
@@ -74,6 +74,10 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
+        struct wchan *lock_wchan;
+        volatile int lock_hold;
+        struct spinlock lk_spinlock;
+        struct thread *lk_thread;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
 
 struct cv {
         char *cv_name;
+        struct wchan *cv_wchan;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
@@ -143,6 +148,10 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 
 struct rwlock {
         char *rwlock_name;
+        struct semaphore *rwlock_semaphore;
+        //struct wchan *rw_wchan;
+        //bool writer_inside;
+        struct lock *rwlock_lock;
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..e46cf78 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -31,6 +31,10 @@
 #define _SYSCALL_H_
 
 
+#include <file_syscall.h>
+#include <psyscall.h>
+
+
 struct trapframe; /* from <machine/trapframe.h> */
 
 /*
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..5f9d0fa 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -105,8 +105,15 @@ int mallocstress(int, char **);
 int nettest(int, char **);
 
 /* Routine for running a user-level program. */
-int runprogram(char *progname);
+//int runprogram(char *progname);
+/**
+ * Author: Pratham Malik
+ * adding arguments parameter for runprogram
+ */
+
+int runprogram(char *progname, char **);
 
+//End of additions by PM
 /* Kernel menu system. */
 void menu(char *argstr);
 
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..5c24d00 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,6 +38,9 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
+#include <file_syscall.h>
+#include <limits.h>
+
 
 struct addrspace;
 struct cpu;
@@ -65,6 +68,8 @@ typedef enum {
 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
 } threadstate_t;
 
+
+
 /* Thread structure. */
 struct thread {
 	/*
@@ -112,6 +117,21 @@ struct thread {
 	struct vnode *t_cwd;		/* current working directory */
 
 	/* add more here as needed */
+
+	/*Added By Mohit
+	 * started
+	 */
+	struct file_descriptor *file_table[__OPEN_MAX];
+	/* Ended */
+
+
+	/*
+	 * Author: Pratham Malik
+	 * Added Process id variable for every thread
+	 */
+	pid_t t_pid;
+	//End of additions by PM
+
 };
 
 /* Call once during system startup to allocate data structures. */
@@ -135,6 +155,7 @@ void thread_shutdown(void);
  * thread should be done only with caution, because in general the
  * child thread might exit at any time.) Returns an error code.
  */
+
 int thread_fork(const char *name, 
                 void (*func)(void *, unsigned long),
                 void *data1, unsigned long data2, 
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..68723b7 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -30,6 +30,7 @@
 /*
  * Main.
  */
+// "Adding for git" marora3@buffalo.edu
 
 #include <types.h>
 #include <kern/errno.h>
@@ -50,11 +51,10 @@
 #include <version.h>
 #include "autoconf.h"  // for pseudoconfig
 
-
 /*
  * These two pieces of data are maintained by the makefiles and build system.
  * buildconfig is the name of the config file the kernel was configured with.
- * buildversion starts at 1 and is incremented every time you link a kernel. 
+ * buildversion starts at 1 and is incremented every time you link a kernel.
  *
  * The purpose is not to show off how many kernels you've linked, but
  * to make it easy to make sure that the kernel you just booted is the
@@ -100,16 +100,19 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+	kprintf("prathamm@buffalo.edu's system version %s (%s #%d)\n",
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
+
 	/* Early initialization. */
 	ram_bootstrap();
 	thread_bootstrap();
 	hardclock_bootstrap();
 	vfs_bootstrap();
 
+
+
 	/* Probe and initialize devices. Interrupts should come on. */
 	kprintf("Device probe...\n");
 	KASSERT(curthread->t_curspl > 0);
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..5d1ec8c 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -100,13 +100,15 @@ cmd_progthread(void *ptr, unsigned long nargs)
 
 	strcpy(progname, args[0]);
 
-	result = runprogram(progname);
+	result = runprogram(progname,args);
 	if (result) {
 		kprintf("Running program %s failed: %s\n", args[0],
 			strerror(result));
 		return;
 	}
 
+	sys___exit(0);
+
 	/* NOTREACHED: runprogram only returns on error. */
 }
 
@@ -133,15 +135,44 @@ common_prog(int nargs, char **args)
 		"synchronization-problems kernel.\n");
 #endif
 
+	/**
+	 * Author: Pratham Malik
+	 * Changing thread
+	 */
+
+	struct thread *childthr;
+	pid_t child_pid;
+
 	result = thread_fork(args[0] /* thread name */,
 			cmd_progthread /* thread function */,
 			args /* thread arg */, nargs /* thread arg */,
-			NULL);
+			&childthr);
 	if (result) {
 		kprintf("thread_fork failed: %s\n", strerror(result));
 		return result;
 	}
 
+	child_pid = childthr->t_pid;
+
+
+ 	int status;
+	int32_t retval;
+
+//	status = kmalloc(sizeof(userptr_t));
+	result = sys___kwaitpid(child_pid,&status,0,&retval);
+	if(result)
+		return result;
+
+
+
+
+/*
+	result = thread_fork(args[0]  thread name ,
+			cmd_progthread  thread function ,
+			args  thread arg , nargs  thread arg ,
+			NULL);
+*/
+
 	return 0;
 }
 
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..ccf4ee2 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -46,15 +46,42 @@
 // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
+struct cv *cv_male;
+struct cv *cv_female;
+struct cv *cv_matchmaker;
+
+
+static volatile int male_count,female_count,matchmaker_count;
+struct lock *matching_lock;
+
+
 
 void whalemating_init() {
-  return;
+  /*
+   * Author: Student
+   * Declaring semaphores for male,female and matchmaker
+   *
+   */
+	cv_male= cv_create("male");
+	cv_female=cv_create("female");
+	cv_matchmaker=cv_create("matchmaker");
+	matching_lock= lock_create("matching_lock");
+	male_count=0;
+	female_count=0;
+	matchmaker_count=0;
+
+	return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
+
+	cv_destroy(cv_male);
+	cv_destroy(cv_female);
+	cv_destroy(cv_matchmaker);
+	lock_destroy(matching_lock);
   return;
 }
 
@@ -62,11 +89,53 @@ void
 male(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
-  (void)which;
-  
-  male_start();
-	// Implement this function 
-  male_end();
+	(void)which;
+
+
+	  male_start();
+	  lock_acquire(matching_lock);
+	  male_count++;
+
+	  if(female_count==0 || matchmaker_count ==0){
+		  cv_wait(cv_male, matching_lock);
+		  male_end();
+	  }
+	  else if(female_count>0 && matchmaker_count >0){
+		 while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
+		 		  if(cv_male->cv_wchan != NULL){
+		 			 cv_signal(cv_male, matching_lock);
+		 			 male_count--;
+		 			 cv_signal(cv_female, matching_lock);
+		 			 cv_signal(cv_matchmaker, matching_lock);
+
+		 		  }
+		 		  else{
+		 			 cv_signal(cv_female, matching_lock);
+		 			 cv_signal(cv_matchmaker, matching_lock);
+		 			 male_count--;
+		 		  }
+
+		 		  male_end();
+
+		 	  }
+	  }
+
+
+
+	  lock_release(matching_lock);
+
+
+
+	// Implement this function
+  /*
+   * Author: Student
+   * Implementing the semaphore for male
+   */
+
+
+//male_end();
+
+
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
@@ -79,11 +148,42 @@ female(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
+
   female_start();
-	// Implement this function 
-  female_end();
-  
+
+  lock_acquire(matching_lock);
+  	  female_count++;
+  	  if(male_count ==0 || matchmaker_count== 0){
+  		  cv_wait(cv_female, matching_lock);
+  		female_end();
+  	  }
+  	  else if(male_count>0 && matchmaker_count >0){
+  		while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
+  		  		  if(cv_female->cv_wchan!= NULL){
+  		  			  cv_signal(cv_male, matching_lock);
+  		  			  male_count--;
+  		  			  cv_signal(cv_female, matching_lock);
+  		  			  female_count--;
+  		  			  cv_signal(cv_matchmaker, matching_lock);
+  		  			  matchmaker_count--;
+
+  		  		  }
+  		  		  else{
+  		  			  cv_signal(cv_male, matching_lock);
+  		  			  male_count--;
+  		  			  cv_signal(cv_matchmaker, matching_lock);
+  		  			  matchmaker_count--;
+  		  			  female_count--;
+  		  		  }
+
+  		  		female_end();
+
+  		  	  }
+  	  }
+
+
+  	  lock_release(matching_lock);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
@@ -95,17 +195,50 @@ matchmaker(void *p, unsigned long which)
 {
 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
   (void)which;
-  
+
   matchmaker_start();
-	// Implement this function 
-  matchmaker_end();
-  
+  lock_acquire(matching_lock);
+  	  matchmaker_count++;
+    	  if(male_count ==0 || female_count==0){
+    		  cv_wait(cv_matchmaker, matching_lock);
+    		  matchmaker_end();
+    	  }
+    	  else if(male_count>0 && female_count >0){
+    		  while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
+    		      if(cv_matchmaker->cv_wchan!= NULL){
+    		         cv_signal(cv_male, matching_lock);
+    		         male_count--;
+    		         cv_signal(cv_female, matching_lock);
+    		         female_count--;
+    		         cv_signal(cv_matchmaker, matching_lock);
+    		         matchmaker_count--;
+
+    		      }
+    		      else{
+    		        cv_signal(cv_male, matching_lock);
+    		        male_count--;
+    		        cv_signal(cv_female, matching_lock);
+    		        female_count--;
+    		      	matchmaker_count--;
+    		      }
+
+        		  matchmaker_end();
+    		  }
+    	  }
+
+
+    	  lock_release(matching_lock);
+  //matchmaker_end();
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // whalemating driver can return to the menu cleanly.
   V(whalematingMenuSemaphore);
   return;
 }
 
+
+
+
 /*
  * You should implement your solution to the stoplight problem below. The
  * quadrant and direction mappings for reference: (although the problem is,
@@ -137,7 +270,22 @@ matchmaker(void *p, unsigned long which)
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+struct cv * cross_intersection;
+struct lock * lock_intersection;
+bool status_busy;
+static volatile int quadrant[4];	//To signify which parts of the quadrant one is occupying, 0 signifies free and 1 signifies taken
+
 void stoplight_init() {
+
+	cross_intersection= cv_create("cross0");
+
+
+	lock_intersection= lock_create("intersection_lock");
+	status_busy=false;
+	quadrant[0]=0;
+	quadrant[1]=0;
+	quadrant[2]=0;
+	quadrant[3]=0;
   return;
 }
 
@@ -145,6 +293,9 @@ void stoplight_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
+	cv_destroy(cross_intersection);
+
+	lock_destroy(lock_intersection);
   return;
 }
 
@@ -153,7 +304,35 @@ gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
+  /*
+   * Author: Student
+   */
   
+  lock_acquire(lock_intersection);
+
+  while(!(quadrant[direction]==0 && (quadrant[(direction+3)%4]==0))){
+	  cv_wait(cross_intersection,lock_intersection);
+
+  }//End of while
+
+  quadrant[direction]=1;
+  quadrant[(direction+3)%4]=1;
+
+  lock_release(lock_intersection);
+
+  inQuadrant(direction);
+  inQuadrant((direction+3)%4);
+  leaveIntersection();
+
+  lock_acquire(lock_intersection);
+  quadrant[direction]=0;
+  quadrant[(direction+3)%4]=0;
+
+	cv_signal(cross_intersection,lock_intersection);
+
+  lock_release(lock_intersection);
+
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -165,6 +344,37 @@ turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
   (void)direction;
+
+  /*
+   *  Author: Student
+     */
+
+  lock_acquire(lock_intersection);
+  while(!(quadrant[direction]==0 && (quadrant[(direction+3)%4]==0)&& (quadrant[(direction+2)%4]==0))){
+	  cv_wait(cross_intersection,lock_intersection);
+  }//End of while
+
+  quadrant[direction]=1;
+  quadrant[(direction+3)%4]=1;
+  quadrant[(direction+2)%4]=1;
+
+  lock_release(lock_intersection);
+
+  inQuadrant(direction);
+  inQuadrant((direction+3)%4);
+  inQuadrant((direction+2)%4);
+  leaveIntersection();
+
+  lock_acquire(lock_intersection);
+  quadrant[direction]=0;
+  quadrant[(direction+3)%4]=0;
+  quadrant[(direction+2)%4]=0;
+
+	cv_signal(cross_intersection,lock_intersection);
+
+  lock_release(lock_intersection);
+
+
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
@@ -180,6 +390,31 @@ turnright(void *p, unsigned long direction)
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
+
+  /*
+   *  Author: Student
+     */
+
+  lock_acquire(lock_intersection);
+
+  while(!(quadrant[direction]==0)){
+	  cv_wait(cross_intersection,lock_intersection);
+  }//End of while
+
+  quadrant[direction]=1;
+
+  lock_release(lock_intersection);
+
+  inQuadrant(direction);
+  leaveIntersection();
+
+  lock_acquire(lock_intersection);
+  quadrant[direction]=0;
+
+	cv_signal(cross_intersection,lock_intersection);
+
+  lock_release(lock_intersection);
+
   V(stoplightMenuSemaphore);
   return;
 }
diff --git a/kern/syscall/file_syscall.c b/kern/syscall/file_syscall.c
new file mode 100644
index 0000000..ac74f6f
--- /dev/null
+++ b/kern/syscall/file_syscall.c
@@ -0,0 +1,494 @@
+/*
+ * file_syscall.c
+ *
+ *  Created on: Mar 1, 2015
+ *      Author: trinity
+ *
+ *      Added By Mohit
+ */
+#include <limits.h>
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <file_syscall.h>
+#include <current.h>
+#include <lib.h>
+#include <synch.h>
+#include <copyinout.h>
+#include <vfs.h>
+#include <uio.h>
+#include <vnode.h>
+#include <stat.h>
+#include <kern/unistd.h>
+#include <kern/seek.h>
+
+
+struct file_descriptor*
+file_descriptor_init(char *name)
+{
+	struct file_descriptor *fd;
+
+		fd = kmalloc(sizeof(struct file_descriptor));
+		if(fd==NULL){
+			return NULL;
+		}
+
+		fd->f_name=kstrdup(name);
+		if(fd->f_name==NULL){
+			kfree(fd);
+			return NULL;
+		}
+
+		fd->f_lock=lock_create(fd->f_name);
+		   	if (fd->f_lock == NULL) {
+		   		kfree(fd->f_lock);
+		   		kfree(fd);
+			    return NULL;
+		}
+
+	return fd;
+
+}
+void
+file_descriptor_cleanup(struct file_descriptor *fd)
+{
+	KASSERT(fd != NULL);
+	lock_destroy(fd->f_lock);
+	kfree(fd->f_name);
+	kfree(fd);
+}
+
+int
+intialize_file_desc_tbl(struct file_descriptor *file_table[]){
+
+
+	char filename[5]= "con:";
+
+	int result;
+	char con_name_in[5];
+	strcpy(con_name_in, filename);
+	struct vnode *v;
+	result= vfs_open(con_name_in, STDIN_FILENO ,0664, &v);
+	if(result){
+		return result;
+	}
+	struct file_descriptor* fd_in;
+	fd_in = intialize_file_desc_con(v, 0, filename, STDIN_FILENO);
+	file_table[0]=fd_in;
+	vfs_close(v);
+
+
+	char con_name_out[5];
+	strcpy(con_name_out, filename);
+	result= vfs_open(con_name_out, STDOUT_FILENO ,0664, &v);
+	if(result){
+		return result;
+	}
+	struct file_descriptor* fd_out;
+	fd_out = intialize_file_desc_con(v, 0, filename, STDOUT_FILENO);
+	file_table[1]=fd_out;
+	vfs_close(v);
+
+	char con_name_err[5];
+	strcpy(con_name_err, filename);
+	result= vfs_open(con_name_err, STDERR_FILENO ,0664, &v);
+	if(result){
+		return result;
+	}
+	struct file_descriptor* fd_err;
+	fd_err = intialize_file_desc_con(v, 0, filename, STDERR_FILENO);
+	file_table[2]=fd_err;
+	vfs_close(v);
+
+	for(int i=3; i<__OPEN_MAX;i++){
+		file_table[i]=0;
+	}
+return 0;
+
+}
+struct file_descriptor*
+intialize_file_desc_con(struct vnode *v, int index, char *file_name, int open_type){
+	struct file_descriptor *fd;
+	fd= file_descriptor_init(file_name);
+	lock_acquire(fd->f_lock);
+	fd->f_flag= open_type;		//fd.f_name= k_des;
+	fd->f_object= v;
+	fd->f_offset=0;
+	fd->reference_count=1;
+	curthread->file_table[index]=fd;
+	lock_release(fd->f_lock);
+return fd;
+}
+
+int
+sys_open(userptr_t filename, int flags, int *return_val)   /*Done using copyinstr as said in blog*/
+{
+	struct file_descriptor *fd;
+	struct vnode *vn;
+	int result;
+	struct stat st;
+	/*void des;
+	size_t length;
+	if((result=copyin((const_userptr_t)filename, &des, length ))!= 0){
+			return result;
+	}*/
+	char k_des[NAME_MAX];
+	size_t actual_length;
+	if((result=copyinstr((const_userptr_t)filename, k_des, NAME_MAX, &actual_length ))!= 0){
+		return result;
+	}
+	char *file_name= k_des;
+		for(int i=3; i<__OPEN_MAX;i++){
+			if(curthread->file_table[i]==  0){
+				if((flags&O_ACCMODE)== O_RDONLY){
+					result= vfs_open(k_des, flags, 0, &vn);
+				}
+				else if((flags&O_ACCMODE)== O_WRONLY){
+					result= vfs_open(k_des, flags, 0, &vn);
+				}
+				else if((flags&O_ACCMODE)== O_RDWR){
+					result= vfs_open(k_des, flags, 0, &vn);
+				}
+				else if((flags&O_APPEND)== O_APPEND){
+					result= vfs_open(k_des, flags, 0, &vn);
+					if(result){
+						return result;
+					}
+					result= VOP_STAT(vn, &st);
+					if(result){
+						return result;
+					}
+				}
+				else{
+					return EINVAL;
+				}
+				if(result){
+					return result;
+				}
+				fd= file_descriptor_init(file_name);
+				lock_acquire(fd->f_lock);
+				if((flags& O_APPEND)== O_APPEND){
+					fd->f_flag= O_APPEND;
+				}
+				else{
+					fd->f_flag= (flags&O_ACCMODE);
+				}
+
+				//fd.f_name= k_des;
+				fd->f_object= vn;
+					fd->f_offset=0;
+				//}
+				fd->reference_count=1;
+				*return_val= i;
+				curthread->file_table[i]=fd;
+				lock_release(fd->f_lock);
+
+				break;
+			}
+		}
+return 0;
+}
+
+int
+sys_close(int fd){						/*I have done KFREE not sure, whether we have to use this or not, Just confirm once again*/
+
+  	if(fd <0 || fd>=__OPEN_MAX){
+			return EBADF;
+	}
+	struct file_descriptor *fd_frm_table;
+	struct vnode *vn;
+	fd_frm_table= curthread->file_table[fd];
+	if(fd_frm_table ==0 ){
+		return EBADF;
+	}
+	lock_acquire(fd_frm_table->f_lock);
+	fd_frm_table->reference_count--;
+	if(fd_frm_table->reference_count == 0){
+		vn= fd_frm_table->f_object;
+		vfs_close(vn);
+		lock_release(fd_frm_table->f_lock);
+		file_descriptor_cleanup(fd_frm_table);
+		//&return_value= 0;
+		curthread->file_table[fd]=0;
+		return 0;
+	}
+	lock_release(fd_frm_table->f_lock);
+	//&return_value=0;
+	return 0;
+}
+
+/*Dont know how to check whether buf is valid address space or not
+ *Need to do that
+ *
+ *
+ *Getting the corresponding file_descriptor object from the table and using to read the data from the file
+ *It means that file need to be open before read
+ *
+ *Saw the code mainly from loadelf.c and rest read the blog and implemented
+ */
+
+int
+sys_read(int fd, userptr_t buf, size_t buflen, int *return_value){
+
+
+
+
+	int result;
+	void* kbuf = kmalloc(buflen);
+	if ((result = copyin((const_userptr_t)buf, kbuf, buflen)) != 0){
+		kfree(kbuf);
+		return result;
+	}
+
+	if(fd <0 || fd>=__OPEN_MAX){
+		return EBADF;
+	}
+	struct file_descriptor *fd_frm_table;
+	struct vnode *vn;
+	struct iovec u_iovec;
+	struct uio u_uio;
+	fd_frm_table= curthread->file_table[fd];
+
+	if(fd_frm_table !=0 ){
+		lock_acquire(fd_frm_table->f_lock);
+		vn= fd_frm_table->f_object;
+
+		u_iovec.iov_ubase= buf;
+		u_iovec.iov_len= buflen;
+		u_uio.uio_iov= &u_iovec;
+		u_uio.uio_iovcnt= 1;
+		u_uio.uio_offset= fd_frm_table->f_offset;
+		u_uio.uio_resid= buflen;
+		u_uio.uio_segflg= UIO_USERSPACE;
+		u_uio.uio_rw= UIO_READ;
+		u_uio.uio_space= curthread->t_addrspace;
+
+		result= VOP_READ(vn, &u_uio);
+		if(result){
+			lock_release(fd_frm_table->f_lock);
+			return result;
+		}
+		else{
+			*return_value= (buflen-u_uio.uio_resid); /*Need to return the length left to read, I think*/
+			fd_frm_table->f_offset+= buflen-u_uio.uio_resid;
+			lock_release(fd_frm_table->f_lock);
+		}
+	}
+	else{
+		return EBADF;
+	}
+
+
+return 0;
+}
+/*
+ * There are some error codes that need to be returned but dont know whether to check them or not
+ */
+int
+sys_write(int fd, userptr_t buf, size_t nbytes, int *return_value){
+
+
+	int result;
+	void* kbuf = kmalloc(nbytes);
+	if ((result = copyin((const_userptr_t)buf, kbuf, nbytes)) != 0){
+		kfree(kbuf);
+		return result;
+	}
+	if(fd <0 || fd>=__OPEN_MAX){
+			return EBADF;
+	}
+	struct file_descriptor *fd_frm_table;
+	struct vnode *vn;
+	struct iovec u_iovec;
+	struct uio u_uio;
+	fd_frm_table= curthread->file_table[fd];
+	if(fd_frm_table != 0){
+		lock_acquire(fd_frm_table->f_lock);
+		if(!(fd_frm_table->f_flag == O_RDWR || fd_frm_table->f_flag == O_WRONLY)){
+			lock_release(fd_frm_table->f_lock);
+			return EROFS;
+		}
+
+		u_uio.uio_offset= fd_frm_table->f_offset;
+		vn= fd_frm_table->f_object;
+		u_iovec.iov_ubase= buf;
+		u_iovec.iov_len= nbytes;
+
+		u_uio.uio_iov= &u_iovec;
+		u_uio.uio_iovcnt= 1;
+
+		u_uio.uio_resid= nbytes;
+		u_uio.uio_rw= UIO_WRITE;
+		u_uio.uio_segflg= UIO_USERSPACE;
+		u_uio.uio_space= curthread->t_addrspace;
+
+		result= VOP_WRITE(vn, &u_uio);
+		if(result){
+			lock_release(fd_frm_table->f_lock);
+			return result;
+		}
+		else{
+			*return_value= (nbytes-u_uio.uio_resid);
+			fd_frm_table->f_offset+= nbytes-u_uio.uio_resid;
+			lock_release(fd_frm_table->f_lock);
+		}
+	}
+	else{
+		return EBADF;
+	}
+
+
+return 0;
+}
+
+int
+dup2(int oldfd, int newfd, int *return_value){
+
+	if(newfd<0 || newfd>=__OPEN_MAX || oldfd<0 || oldfd>=__OPEN_MAX){
+		return EBADF;
+	}
+	else{
+		struct file_descriptor *fd;
+		fd= curthread->file_table[oldfd];
+		if(fd==0){
+			return EBADF;
+		}
+		int count=0;
+		for(int i=3; i<__OPEN_MAX;i++){
+			if(curthread->file_table[i]!= 0){
+				count++;
+			}
+			else{
+				break;
+			}
+		}
+		if(count== __OPEN_MAX){
+			return EMFILE;
+		}
+		if(newfd != oldfd){
+			if(curthread->file_table[newfd]!= 0){
+				sys_close(newfd);
+			}
+			curthread->file_table[newfd]= fd;
+			fd->reference_count++;
+			*return_value= newfd;
+		}
+	}
+return 0;
+}
+
+int
+__getcwd(userptr_t buf, size_t buflen, int *return_value){
+	int result;
+	char k_des[PATH_MAX];
+	size_t actual_length;
+	if((result=copyinstr((const_userptr_t)buf, k_des, PATH_MAX, &actual_length ))!= 0){
+		return result;
+	}
+	struct uio u_uio;
+	struct iovec u_iovec;
+	u_iovec.iov_ubase= buf;
+	u_iovec.iov_len= buflen;
+
+	u_uio.uio_iov= &u_iovec;
+	u_uio.uio_iovcnt= 1;
+	u_uio.uio_offset=0;
+	u_uio.uio_resid= buflen;
+	u_uio.uio_rw= UIO_READ;
+	u_uio.uio_segflg= UIO_USERSPACE;
+	u_uio.uio_space= curthread->t_addrspace;
+
+	result = vfs_getcwd(&u_uio);
+	if (result) {
+		return result;
+	}
+	*return_value= u_uio.uio_resid;
+
+return 0;
+}
+
+int
+chdir(userptr_t pathname){
+	int result;
+	char k_des[PATH_MAX];
+	size_t actual_length;
+	if((result=copyinstr((const_userptr_t)pathname, k_des, PATH_MAX, &actual_length ))!= 0){
+		return result;
+	}
+	result= vfs_chdir(k_des);
+	if(result){
+		return result;
+	}
+
+return 0;
+}
+
+int
+lseek(int fd, off_t pos, int32_t whence, int32_t *return_value1, int32_t *return_value2){
+
+	if(fd <0 || fd>=__OPEN_MAX){
+		return EBADF;
+	}
+	struct file_descriptor *fd_frm_table;
+	fd_frm_table= curthread->file_table[fd];
+	if(fd_frm_table == 0){
+			return EBADF;
+	}
+	//int32_t *sz= &whence;
+	int* kbuf = kmalloc(sizeof(whence));
+	int result;
+	if ((result = copyin((const_userptr_t)whence, kbuf, sizeof(whence))) != 0){
+		kfree(kbuf);
+		return result;
+	}
+	struct vnode *vn;
+	struct stat st;
+	lock_acquire(fd_frm_table->f_lock);
+	vn= fd_frm_table->f_object;
+	int c_pos= fd_frm_table->f_offset;
+
+	if((*kbuf&O_ACCMODE)== SEEK_SET){
+		result= VOP_TRYSEEK(vn, pos);
+			if(result){
+				lock_release(fd_frm_table->f_lock);
+				return result;
+			}
+			fd_frm_table->f_offset= pos;
+
+	}
+	else if((*kbuf&O_ACCMODE)== SEEK_CUR){
+		result= VOP_TRYSEEK(vn, (pos+c_pos));
+			if(result){
+				lock_release(fd_frm_table->f_lock);
+				return result;
+			}
+			fd_frm_table->f_offset= pos+c_pos;
+	}
+	else if((*kbuf&O_ACCMODE)== SEEK_END){
+
+		result= VOP_STAT(vn, &st);
+		if(result){
+		lock_release(fd_frm_table->f_lock);
+		return result;
+		}
+		off_t eof= st.st_size;
+		result= VOP_TRYSEEK(vn, (pos+eof));
+		if(result){
+		lock_release(fd_frm_table->f_lock);
+		return result;
+		}
+		fd_frm_table->f_offset= pos+eof;
+	}
+	else{
+		return EINVAL;
+	}
+	int64_t final_value= fd_frm_table->f_offset;
+	int32_t high = (int32_t)((final_value & 0xFFFFFFFF00000000) >> 32);
+	int32_t low = (int32_t)(final_value & 0xFFFFFFFF);
+	*return_value1= high;
+	*return_value2= low;
+	lock_release(fd_frm_table->f_lock);
+
+
+return 0;
+}
diff --git a/kern/syscall/psyscall.c b/kern/syscall/psyscall.c
new file mode 100644
index 0000000..e1531ac
--- /dev/null
+++ b/kern/syscall/psyscall.c
@@ -0,0 +1,532 @@
+
+#include <types.h>
+#include <clock.h>
+#include <copyinout.h>
+#include <lib.h>
+#include <limits.h>
+#include <thread.h>
+#include <current.h>
+#include <synch.h>
+#include <psyscall.h>
+#include <kern/errno.h>
+#include <addrspace.h>
+#include <mips/trapframe.h>
+#include <kern/wait.h>
+#include <kern/fcntl.h>
+#include <vm.h>
+#include <vfs.h>
+#include <syscall.h>
+#include <test.h>
+#include <file_syscall.h>
+
+
+
+void
+initialize_pid(struct thread *thr,pid_t processid)
+{
+	if(curthread!=NULL)
+		lock_acquire(pid_lock);
+	struct process_control *p_array;
+
+	p_array=kmalloc(sizeof(struct process_control));
+
+	thr->t_pid=processid;
+
+	p_array->parent_id=-1;
+	p_array->childlist=NULL;
+	p_array->exit_code=-1;
+	p_array->exit_status=false;
+	p_array->mythread=thr;
+	p_array->waitstatus=false;
+	p_array->process_sem = sem_create(thr->t_name,0);
+
+	//Create the lock and CV
+	p_array->process_lock=lock_create(thr->t_name);
+	p_array->process_cv = cv_create(thr->t_name);
+
+	//Copy back into the thread
+	process_array[processid]=p_array;
+
+	if(curthread!=NULL)
+		lock_release(pid_lock);
+
+}
+
+pid_t
+allocate_pid(void)
+{
+	for(int i=PID_MIN;i<PROCESS_MAX;i++)
+	{
+		if(process_array[i]==0)
+		{
+			return i;
+			break;
+		}
+	}
+	return -1;
+}
+
+void
+deallocate_pid(pid_t processid)
+{
+
+	if(process_array[processid]==0 || process_array[processid]==NULL)
+	{
+		//Do Nothing
+	}
+	else
+	{
+		pid_t parent_id = process_array[processid]->parent_id;
+		if(parent_id>PID_MIN)
+		{
+				int counter=0;
+				for(counter=3;counter<__OPEN_MAX;counter++)
+				{
+					if(curthread->file_table[counter]!=0)
+					{
+						process_array[parent_id]->mythread->file_table[counter]->reference_count--;
+					}
+					else
+					{
+							//newthread->file_table[counter]=0;
+					}
+				}
+		}
+
+		sem_destroy(process_array[processid]->process_sem);
+		lock_destroy(process_array[processid]->process_lock);
+		cv_destroy(process_array[processid]->process_cv);
+		kfree(process_array[processid]);
+		process_array[processid]=0;
+
+	}
+}
+
+int
+sys___exit(int exit_code)
+{
+	//Check whether the process calling exit has no children?
+
+	pid_t pid_process=curthread->t_pid;
+
+	//Check whether to indicate exit by calling cv_broadcast as well
+//	cv_broadcast(process_array[pid_process]->process_cv,process_array[pid_process]->process_lock);
+
+	//Now using a semaphore and V when the thread exits
+	if(process_array[pid_process]->waitstatus==true)
+	{
+		lock_acquire(process_array[pid_process]->process_lock);
+
+		//Indicate Exit by calling changing the exit status in the process array
+		process_array[pid_process]->exit_code= _MKWAIT_EXIT(exit_code);
+
+		process_array[pid_process]->exit_status=true;
+
+		cv_signal(process_array[pid_process]->process_cv,process_array[pid_process]->process_lock);
+
+		lock_release(process_array[pid_process]->process_lock);
+
+	}
+		//V(process_array[pid_process]->process_sem);
+	else
+	{
+		lock_acquire(process_array[pid_process]->process_lock);
+
+		//Store the exit code passed in the argument
+		process_array[pid_process]->exit_code= _MKWAIT_EXIT(exit_code);
+
+		//Indicate Exit by calling changing the exit status in the process array
+		process_array[pid_process]->exit_status=true;
+
+		lock_release(process_array[pid_process]->process_lock);
+
+	}
+
+	thread_exit();
+
+	return 0;
+}
+
+int
+sys___getpid(int32_t *retval)
+{
+	*retval = curthread->t_pid;
+	return 0;
+}
+
+int
+sys___waitpid(int processid,userptr_t  status,int options, int32_t *retval)
+{
+	//pid_t pid_process= (int32_t) processid;
+	int exit_code;
+	int result;
+
+//	userptr_t user_status;
+
+/*
+	if(processid<PID_MIN)
+		return ESRCH;
+*/
+
+	if( options!=0){
+		return EINVAL;
+	}
+	//Check whether the pid exists
+	if(processid<PID_MIN || process_array[processid]==0 ||process_array[processid]==NULL)
+	{
+		return ESRCH;
+	}
+
+	//CHeck if the status is not NULL
+	if(status==NULL)
+		return EFAULT;
+
+	if (processid < PID_MIN)
+		return EINVAL;
+
+	if(processid > PID_MAX)
+		return ESRCH;
+
+	if (processid == curthread->t_pid)
+		return ECHILD;
+
+	//TODO::Check whether the pid exists in your child list -- Complete after fork - Completed below
+	if(!(curthread->t_pid == process_array[processid]->parent_id))
+		return ECHILD;
+
+
+	if(process_array[processid]->exit_status==true)
+	{
+		lock_acquire(process_array[processid]->process_lock);
+
+		exit_code = process_array[processid]->exit_code;
+
+		lock_release(process_array[processid]->process_lock);
+
+		result = copyout(&exit_code,status,sizeof(userptr_t));
+		if(result)
+			return result;
+
+		//Destroy Child's Process Structure - Call deallocate_pid
+
+		*retval = processid;
+		deallocate_pid(processid);
+
+	}
+	else if(process_array[processid]->exit_status==false)
+	{
+		lock_acquire(process_array[processid]->process_lock);
+
+		process_array[processid]->waitstatus=true;
+		cv_wait(process_array[processid]->process_cv,process_array[processid]->process_lock);
+
+		//P(process_array[pid_process]->process_sem);
+		exit_code = process_array[processid]->exit_code;
+
+		lock_release(process_array[processid]->process_lock);
+
+		result = copyout(&exit_code,status,sizeof(userptr_t));
+			if(result)
+					return result;
+
+		//Destroy Child's Process Structure - Call deallocate_pid
+
+		*retval = processid;
+		deallocate_pid(processid);
+	}
+
+		return 0;
+}
+
+int
+sys___kwaitpid(int processid,int *status,int options, int32_t *retval)
+{
+	//pid_t pid_process= (int32_t) processid;
+	int exit_code;
+//	int result;
+
+//	userptr_t user_status;
+
+/*
+	if(processid<PID_MIN)
+		return ESRCH;
+*/
+
+	if( options!=0){
+		return EINVAL;
+	}
+	//Check whether the pid exists
+	if(processid<PID_MIN || process_array[processid]==0 ||process_array[processid]==NULL)
+	{
+		return ESRCH;
+	}
+
+	//CHeck if the status is not NULL
+	if(status==NULL)
+		return EFAULT;
+
+	if (processid < PID_MIN)
+		return EINVAL;
+
+	if(processid > PID_MAX)
+		return ESRCH;
+
+	if (processid == curthread->t_pid)
+		return ECHILD;
+
+	//TODO::Check whether the pid exists in your child list -- Complete after fork - Completed below
+	if(!(curthread->t_pid == process_array[processid]->parent_id))
+		return ECHILD;
+
+
+	if(process_array[processid]->exit_status==true)
+	{
+		lock_acquire(process_array[processid]->process_lock);
+
+		exit_code = process_array[processid]->exit_code;
+
+		lock_release(process_array[processid]->process_lock);
+
+		status = &exit_code;
+
+	/*	result = copyout(&exit_code,status,sizeof(userptr_t));
+		if(result)
+			return result;
+*/
+		//Destroy Child's Process Structure - Call deallocate_pid
+
+		*retval = processid;
+		deallocate_pid(processid);
+
+	}
+	else if(process_array[processid]->exit_status==false)
+	{
+		lock_acquire(process_array[processid]->process_lock);
+
+		process_array[processid]->waitstatus=true;
+		cv_wait(process_array[processid]->process_cv,process_array[processid]->process_lock);
+
+		//P(process_array[pid_process]->process_sem);
+		exit_code = process_array[processid]->exit_code;
+
+		lock_release(process_array[processid]->process_lock);
+
+		status = &exit_code;
+
+		/*result = copyout(&exit_code,status,sizeof(userptr_t));
+			if(result)
+					return result;
+*/
+		//Destroy Child's Process Structure - Call deallocate_pid
+
+		*retval = processid;
+		deallocate_pid(processid);
+	}
+
+		return 0;
+}
+
+
+
+/*
+ * Fork System Call:: Forks a new process
+ * Returns two values to child and Parent.
+
+*/
+struct sendthing
+{
+	struct addrspace *parentaddr;
+	struct trapframe *childtf;
+};
+int
+sys___fork(struct trapframe *tf, pid_t *returnval)
+{
+	int result;
+	struct thread *child;
+	struct trapframe *parent_tf;
+
+	parent_tf = kmalloc(sizeof(struct trapframe));
+	if(parent_tf==NULL)
+		return ENOMEM;
+
+	memcpy(parent_tf,tf,sizeof(struct trapframe));
+//	parent_tf=tf;
+
+	pid_t current_pid = curthread->t_pid;
+
+	unsigned long parent_pid;
+	parent_pid = (unsigned long) current_pid;
+
+	result = thread_fork(curthread->t_name,enter_process,parent_tf,parent_pid,&child);
+	if(result){
+	//	kfree(parent_tf);
+		if(process_array[child->t_pid] == 0 || process_array[child->t_pid] == NULL)
+		{
+			//Do Nothing
+		}
+		else
+		{
+			kfree(process_array[child->t_pid]);
+		}
+
+	//
+		return result;
+	}
+
+	*returnval = child->t_pid;
+
+	return 0;
+}
+
+void
+enter_process(void *tf,unsigned long addr)
+{
+	struct trapframe *childframe,child_tf;
+	struct addrspace *childspace;
+	if(tf!=NULL)
+	{
+
+		tf = (struct trapframe *) tf;
+		childframe = tf;
+		//copy the trapframe info now into the child_tf
+
+
+	//	child_tf = *childframe;
+
+		memcpy(&child_tf,tf,sizeof(struct trapframe));
+
+		child_tf.tf_a3=0;
+		child_tf.tf_v0=0;
+
+		child_tf.tf_epc +=4;
+
+
+		pid_t parentid = (pid_t)addr;
+		if(process_array[curthread->t_pid]->parent_id!=parentid)
+			process_array[curthread->t_pid]->parent_id=parentid;
+
+		if(!(curthread->t_addrspace==NULL))
+		{
+			childspace = curthread->t_addrspace;
+			as_activate(childspace);
+		}
+		mips_usermode(&child_tf);
+	}
+}
+
+
+int
+sys___execv(userptr_t p_name,userptr_t ar)
+{
+	struct vnode *p_vnode;
+	vaddr_t entrypoint, stackptr;
+
+	int result;
+	int counter;
+	size_t copied_length;
+
+	char *kname; // name of the program copied in kernel
+//	char *pname; //	name of pname
+
+//	pname = (char *) p_name;
+
+/*
+	if(p_name==NULL)
+		return EFAULT;
+
+	if(ar==NULL)
+		return EFAULT;
+
+	if(pname == '\0')
+		return ENOEXEC;
+*/
+
+	kname = (char *) kmalloc(sizeof(p_name));
+	if(kname==NULL)
+		return ENOMEM;
+
+//	result = copyin(p_name,kname,sizeof(p_name));
+	result = copyinstr(p_name,kname,sizeof(p_name),&copied_length);
+	if(result)
+	{
+
+		kfree(kname);
+		return result;
+	}
+
+/*
+	if(copied_length == 1)
+	{
+		kfree(kname);
+		return EINVAL;
+	}
+*/
+
+	//Copy into the kernel buffer
+	char **user_args = (char **) ar;
+
+	char **kernel_buffer = kmalloc(sizeof(char *));;
+	if(kernel_buffer==NULL)
+	{
+		kfree(kname);
+		return ENOMEM;
+	}
+
+	counter =0;
+	while(user_args[counter] != NULL)
+	{
+		char *temp = user_args[counter];
+
+		result = copyinstr((const_userptr_t)temp,kernel_buffer[counter],sizeof(temp),&copied_length);
+		if(result)
+		{
+			kfree(kname);
+			kfree(kernel_buffer);
+			return result;
+		}
+		counter++;
+
+	}
+
+	/* Open the file. */
+	result = vfs_open(kname, O_RDONLY, 0, &p_vnode);
+	if (result) {
+		return result;
+	}
+
+	/* We should be a new thread. */
+	KASSERT(curthread->t_addrspace == NULL);
+
+	/* Create a new address space. */
+	curthread->t_addrspace = as_create();
+	if (curthread->t_addrspace==NULL) {
+		vfs_close(p_vnode);
+		return ENOMEM;
+	}
+
+	/* Activate it. */
+	as_activate(curthread->t_addrspace);
+
+	/* Load the executable. */
+	result = load_elf(p_vnode, &entrypoint);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		vfs_close(p_vnode);
+		return result;
+	}
+
+	/* Done with the file now. */
+	vfs_close(p_vnode);
+
+	/* Define the user stack in the address space */
+	result = as_define_stack(curthread->t_addrspace, &stackptr);
+	if (result) {
+		/* thread_exit destroys curthread->t_addrspace */
+		return result;
+	}
+
+
+	return 0;
+}
+
+
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..a2ada5e 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -44,20 +44,109 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
+#include <file_syscall.h>
 
+#include <copyinout.h>
 /*
+ *
  * Load program "progname" and start running it in usermode.
  * Does not return except on error.
  *
  * Calls vfs_open on progname and thus may destroy it.
  */
 int
-runprogram(char *progname)
+runprogram(char *progname,char **argss)
 {
 	struct vnode *v;
 	vaddr_t entrypoint, stackptr;
 	int result;
 
+	if(argss==NULL)
+	{
+		//Do Nothing
+
+	}
+	else
+	{
+		char **user_args;
+		user_args = kmalloc(sizeof(char **));
+
+		user_args[0]=argss[0];
+
+	}
+/*
+
+	*
+	 * Author:Pratham Malik
+	 * adding arguments to stack
+
+	int counter;
+	char **user_args;
+	char *temp;
+	char *final;
+	int string_length;
+	int new_length;
+	int i;
+
+	counter=0;
+	string_length=0;
+
+
+	user_args = kmalloc(sizeof(char **));
+
+	while(argss[counter] != NULL)
+	{
+		temp = kstrdup(argss[counter]);
+		kprintf("The argument is %s",temp);
+
+		string_length = strlen(temp);
+		if((string_length) % 4 == 0)
+		{
+			user_args[counter] = kmalloc(sizeof(string_length));
+//			result= copyout(temp,(userptr_t) user_args[counter],sizeof(string_length));
+//			if(result)
+//				return result;
+
+			user_args[counter] = temp;
+		}
+		else
+		{
+
+			new_length = string_length;
+			while(new_length%4 !=0)
+			{
+				new_length++;
+			}
+
+			final=temp;
+
+			for(i=string_length;i<=new_length;i++)
+			{
+				final[i]= '\0';
+			}
+
+			user_args[counter] = kmalloc(sizeof(new_length));
+			user_args[counter] = final;
+//			result = copyout(final,(userptr_t) user_args[counter],sizeof(new_length));
+				if(result)
+					return result;
+
+
+		}
+		counter++;
+	}
+
+
+	char **userspacearg = kmalloc(sizeof(user_args));
+	result = copyout(user_args,(userptr_t) userspacearg,sizeof(userspacearg));
+	if(result)
+		return result;
+
+
+	//End of additions by PM
+
+
+*/
 	/* Open the file. */
 	result = vfs_open(progname, O_RDONLY, 0, &v);
 	if (result) {
@@ -74,6 +163,7 @@ runprogram(char *progname)
 		return ENOMEM;
 	}
 
+
 	/* Activate it. */
 	as_activate(curthread->t_addrspace);
 
@@ -95,12 +185,32 @@ runprogram(char *progname)
 		return result;
 	}
 
+
+
+
+/**
+ * Author: Mohit Arora
+ * Initialing the file table
+ */
+	int result1=100;
+	kprintf("Inside run program");
+	result1= intialize_file_desc_tbl(curthread->file_table);
+	if( intialize_file_desc_tbl(curthread->file_table)){
+		kprintf("Error");
+		return result1;
+	}
+
+//End of Additions by MA
+
 	/* Warp to user mode. */
 	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
 			  stackptr, entrypoint);
 	
+
 	/* enter_new_process does not return. */
 	panic("enter_new_process returned\n");
 	return EINVAL;
 }
 
+
+
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..f27b083 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -40,6 +40,7 @@
 #include <current.h>
 #include <synch.h>
 
+
 ////////////////////////////////////////////////////////////
 //
 // Semaphore.
@@ -87,8 +88,7 @@ sem_destroy(struct semaphore *sem)
         kfree(sem);
 }
 
-void 
-P(struct semaphore *sem)
+void P(struct semaphore *sem)
 {
         KASSERT(sem != NULL);
 
@@ -150,6 +150,9 @@ V(struct semaphore *sem)
 struct lock *
 lock_create(const char *name)
 {
+
+	DEBUG(DB_THREADS,
+							      "Inside Lock_create");
         struct lock *lock;
 
         lock = kmalloc(sizeof(struct lock));
@@ -164,7 +167,18 @@ lock_create(const char *name)
         }
         
         // add stuff here as needed
-        
+        lock->lock_wchan = wchan_create(lock->lk_name);
+        	if (lock->lock_wchan == NULL) {
+        		kfree(lock->lk_name);
+        		kfree(lock);
+        		return NULL;
+        	}
+        spinlock_init(&lock->lk_spinlock);
+        lock->lock_hold=0;
+        lock->lk_thread= NULL;
+
+        DEBUG(DB_THREADS,
+        				"Exiting lock_create");
         return lock;
 }
 
@@ -174,7 +188,8 @@ lock_destroy(struct lock *lock)
         KASSERT(lock != NULL);
 
         // add stuff here as needed
-        
+        wchan_destroy(lock->lock_wchan);
+        spinlock_cleanup(&lock->lk_spinlock);
         kfree(lock->lk_name);
         kfree(lock);
 }
@@ -183,26 +198,81 @@ void
 lock_acquire(struct lock *lock)
 {
         // Write this
+	DEBUG(DB_THREADS,
+	        				"Inside lock_acquire");
+	struct thread *mythread;
+	KASSERT(lock != NULL);
+    KASSERT(curthread->t_in_interrupt == false);
+
+	spinlock_acquire(&lock->lk_spinlock);
+
+	while(lock->lock_hold==1){
+		wchan_lock(lock->lock_wchan);
+		spinlock_release(&lock->lk_spinlock);
+		wchan_sleep(lock->lock_wchan);
+		spinlock_acquire(&lock->lk_spinlock);
+	}
+/*	else if(lock->lock_hold==0){
+		if (CURCPU_EXISTS()) {
+				mythread = curthread;
+				if (lock->lk_thread == mythread) {
+					panic("Deadlock on thread %p\n", lock);
+				}
+			}
+			else {
+				mythread = NULL;
+			} */
+
+	if(curthread!= NULL){
+				 mythread = curthread;
+				 lock->lk_thread = mythread;
+	}
+	lock->lock_hold= 1;
+
+	spinlock_release(&lock->lk_spinlock);
 
-        (void)lock;  // suppress warning until code gets written
+	  //KASSERT(lock->lock_count > 0);
+
+       //(void)lock;  // suppress warning until code gets written
+	DEBUG(DB_THREADS,
+	        				"Exiting lock_acquire");
 }
 
 void
 lock_release(struct lock *lock)
 {
         // Write this
+    KASSERT(lock != NULL);
+    spinlock_acquire(&lock->lk_spinlock);
+
+    lock->lock_hold=0;
+    KASSERT(lock->lock_hold== 0);
+    lock->lk_thread= NULL;
+    wchan_wakeone(lock->lock_wchan);
 
-        (void)lock;  // suppress warning until code gets written
+    spinlock_release(&lock->lk_spinlock);
+       // (void)lock;  // suppress warning until code gets written
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
-
-        return true; // dummy until code gets written
+	if (!CURCPU_EXISTS()) {
+			return true;
+		}
+//	if(lock->lk_holder== curcpu->c_self){
+//		return true;
+//	}
+	//KASSERT(lock->lk_thread != NULL);
+	//KASSERT(lock != NULL);
+	bool value= false;
+
+        //(void)lock;  // suppress warning until code gets written
+	spinlock_acquire(&lock->lk_spinlock);
+        value= (lock->lk_thread== curthread); // dummy until code gets written
+        spinlock_release(&lock->lk_spinlock);
+        return value;
 }
 
 ////////////////////////////////////////////////////////////
@@ -227,7 +297,20 @@ cv_create(const char *name)
         }
         
         // add stuff here as needed
-        
+        /*
+         * @Author: Student
+         * Implementing Condition Variable by defining the name
+         * and initializing the wait channel
+         */
+
+        cv->cv_wchan= wchan_create(cv->cv_name);
+		if (cv->cv_wchan == NULL) {
+			kfree(cv->cv_name);
+			kfree(cv);
+			return NULL;
+		}
+
+
         return cv;
 }
 
@@ -246,22 +329,147 @@ void
 cv_wait(struct cv *cv, struct lock *lock)
 {
         // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+//        (void)cv;    // suppress warning until code gets written
+  //      (void)lock;  // suppress warning until code gets written
+
+        /*
+         * Author: Student
+         */
+        if(lock_do_i_hold(lock)) {
+        
+		wchan_lock(cv->cv_wchan);
+		//Release the supplied lock
+		lock_release(lock);
+			wchan_sleep(cv->cv_wchan);
+
+		lock_acquire(lock);
+				
+        }
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
         // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+//	(void)cv;    // suppress warning until code gets written
+//	(void)lock;  // suppress warning until code gets written
+
+	/*
+	 * Author: Student
+	 * Wake up the wchan which is sleeping on the CV
+	 */
+	if(lock_do_i_hold(lock))
+	{
+		wchan_wakeone(cv->cv_wchan);
+	}
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+//	(void)cv;    // suppress warning until code gets written
+//	(void)lock;  // suppress warning until code gets written
+	if(lock_do_i_hold(lock)) {
+	wchan_wakeall(cv->cv_wchan);
+	}
 }
+///////////////////////////////////////////////
+//RW Locks
+
+
+struct rwlock *
+rwlock_create(const char *name)
+{
+	struct rwlock *rw;
+
+	rw = kmalloc(sizeof(rw));
+	if(rw==NULL){
+		return NULL;
+	}
+
+	rw->rwlock_name=kstrdup(name);
+	if(rw->rwlock_name==NULL){
+		kfree(rw);
+		return NULL;
+	}
+
+
+	//Create Semaphore
+	rw->rwlock_semaphore = sem_create(rw->rwlock_name,MAX_READ);
+	if (rw->rwlock_semaphore == NULL) {
+			kfree(rw->rwlock_name);
+			kfree(rw);
+			return NULL;
+	}
+	//rw->read_count=0;
+	//Create Lock
+	rw->rwlock_lock=lock_create(rw->rwlock_name);
+   	if (rw->rwlock_lock == NULL) {
+   		kfree(rw->rwlock_name);
+   		kfree(rw);
+	    return NULL;
+	}
+
+	return rw;
+}
+
+void
+rwlock_destroy(struct rwlock *rw_lock)
+{
+	KASSERT(rw_lock != NULL);
+
+	        // add stuff here as needed
+		sem_destroy(rw_lock->rwlock_semaphore);
+		lock_destroy(rw_lock->rwlock_lock);
+	    kfree(rw_lock->rwlock_name);
+	    kfree(rw_lock);
+}
+void
+rwlock_acquire_read(struct rwlock *rw_lock)
+{
+	lock_acquire(rw_lock->rwlock_lock);
+
+	P(rw_lock->rwlock_semaphore);
+	//rw_lock->read_count++;
+
+	lock_release(rw_lock->rwlock_lock);
+}
+
+void
+rwlock_release_read(struct rwlock *rw_lock){
+
+	V(rw_lock->rwlock_semaphore);
+	//rw_lock->read_count--;
+}
+
+void
+rwlock_acquire_write(struct rwlock *rw_lock){
+
+	lock_acquire(rw_lock->rwlock_lock);
+
+	while(1)
+	{
+		if(rw_lock->rwlock_semaphore->sem_count!=MAX_READ)
+			continue;
+		else if(rw_lock->rwlock_semaphore->sem_count==MAX_READ)
+		{
+			rw_lock->rwlock_semaphore->sem_count=1;
+			P(rw_lock->rwlock_semaphore);
+			break;
+		}
+	}
+
+	lock_release(rw_lock->rwlock_lock);
+}
+
+void
+rwlock_release_write(struct rwlock *rw_lock){
+
+	rw_lock->rwlock_semaphore->sem_count=MAX_READ-1;
+	V(rw_lock->rwlock_semaphore);
+
+
+}
+
+
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..af81457 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -47,9 +47,32 @@
 #include <addrspace.h>
 #include <mainbus.h>
 #include <vnode.h>
+/* Added for file table size*/
+
+/**
+ * Author: Pratham Malik
+ */
+#include <psyscall.h>
+struct process_control *process_array[PROCESS_MAX];
+struct lock *pid_lock;
+
+//End of Additions by PM
+
+
 
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
+/*
+ * Author: Pratham Malik
+ * Added header file for process syscalls
+ */
+//#include <psyscall.h>
+#include <limits.h>
+
+extern struct process_control *process_array[PROCESS_MAX];
+struct lock *pid_lock;
+
+//End of adding by Pratham Malik
 
 
 /* Magic number used as a guard value on kernel thread stacks. */
@@ -154,6 +177,28 @@ thread_create(const char *name)
 
 	/* If you add to struct thread, be sure to initialize here */
 
+	/*Added BY Mohit
+	 *started
+	 */
+	/*Ended*/
+
+	/**
+	 * Author: Pratham Malik
+	 * Initialize PID to the process
+	 */
+	pid_t processid;
+	processid = allocate_pid();
+	if(processid==-1)
+	{
+		kfree(thread);
+		return NULL;
+	}
+
+	initialize_pid(thread,processid);
+
+	//End of Additions by Pratham Malik
+
+
 	return thread;
 }
 
@@ -168,6 +213,8 @@ thread_create(const char *name)
 struct cpu *
 cpu_create(unsigned hardware_number)
 {
+	DEBUG(DB_THREADS,
+					      "Inside cpu_create");
 	struct cpu *c;
 	int result;
 	char namebuf[16];
@@ -223,6 +270,9 @@ cpu_create(unsigned hardware_number)
 
 	cpu_machdep_init(c);
 
+	DEBUG(DB_THREADS,
+					      "Leaving cpu_create");
+
 	return c;
 }
 
@@ -293,6 +343,8 @@ exorcise(void)
 void
 thread_panic(void)
 {
+	DEBUG(DB_THREADS,
+					      "Inside thread_panic");
 	/*
 	 * Kill off other CPUs.
 	 *
@@ -327,6 +379,8 @@ thread_panic(void)
 	 * might be needed. It may also be necessary to go through and
 	 * forcibly unlock all locks or the like...
 	 */
+	DEBUG(DB_THREADS,
+						      "Exiting thread_panic");
 }
 
 /*
@@ -350,12 +404,30 @@ thread_shutdown(void)
 void
 thread_bootstrap(void)
 {
+
 	struct cpu *bootcpu;
 	struct thread *bootthread;
 
+
+
 	cpuarray_init(&allcpus);
 
 	/*
+	 * Author:Pratham Malik
+	 * Initialize the structure for process to zero
+	*/
+	int count=0;
+	for(count=0;count<PROCESS_MAX;count++)
+	{
+		process_array[count]=0;
+	}
+
+	//Create the pid_lock
+	pid_lock = lock_create("pid_lock");
+	//End of Addition by PM
+
+
+	/*
 	 * Create the cpu structure for the bootup CPU, the one we're
 	 * currently running on. Assume the hardware number is 0; that
 	 * might be updated later by mainbus-type code. This also
@@ -382,6 +454,8 @@ thread_bootstrap(void)
 	curcpu->c_curthread = curthread;
 
 	/* Done */
+
+
 }
 
 /*
@@ -436,6 +510,7 @@ static
 void
 thread_make_runnable(struct thread *target, bool already_have_lock)
 {
+
 	struct cpu *targetcpu;
 	bool isidle;
 
@@ -483,6 +558,7 @@ thread_fork(const char *name,
 	    struct thread **ret)
 {
 	struct thread *newthread;
+	struct addrspace *childspace;
 
 	newthread = thread_create(name);
 	if (newthread == NULL) {
@@ -493,11 +569,46 @@ thread_fork(const char *name,
 	newthread->t_stack = kmalloc(STACK_SIZE);
 	if (newthread->t_stack == NULL) {
 		thread_destroy(newthread);
+	//	kfree(process_array[newthread->t_pid]);
 		return ENOMEM;
 	}
 	thread_checkstack_init(newthread);
 
 	/*
+	 * Author: Pratham Malik
+	 * Copy the addrspace for the child
+	 */
+	int result;
+
+	if(curthread->t_addrspace!=NULL)
+	{
+		/*childspace = kmalloc(sizeof(struct addrspace));
+		if(childspace == NULL)
+		{
+			kfree(process_array[newthread->t_pid]);
+			return ENOMEM;
+		}
+*/
+		result = as_copy(curthread->t_addrspace,&childspace);
+		if(result)
+		{
+			//kfree(process_array[newthread->t_pid]);
+			return result;
+
+		}
+
+//		memcpy(newthread->t_addrspace,childspace,sizeof(childspace));
+		newthread->t_addrspace = childspace;
+
+		if(newthread->t_addrspace==NULL)
+		{
+			//kfree(process_array[newthread->t_pid]);
+			return ENOMEM;
+		}
+	}
+	//End of additions by PM
+
+	/*
 	 * Now we clone various fields from the parent thread.
 	 */
 
@@ -513,6 +624,34 @@ thread_fork(const char *name,
 		newthread->t_cwd = curthread->t_cwd;
 	}
 
+	/**
+	 * Author: Pratham Malik
+	 */
+
+	int counter=0;
+	for(counter=0;counter<__OPEN_MAX;counter++)
+	{
+		if(curthread->file_table[counter]!=0)
+		{
+			//newthread->file_table[counter]=kmalloc(sizeof(struct file_descriptor));
+			newthread->file_table[counter]=curthread->file_table[counter];
+			if(counter>2)
+				curthread->file_table[counter]->reference_count++;
+		}else
+		{
+			newthread->file_table[counter]=0;
+		}
+	}
+
+	//Also add the parent id to the process array entry for the new child
+	pid_t parent_id = curthread->t_pid;
+	pid_t child_id = newthread->t_pid;
+
+	process_array[child_id]->parent_id = parent_id;
+
+	//End by PM
+
+
 	/*
 	 * Because new threads come out holding the cpu runqueue lock
 	 * (see notes at bottom of thread_switch), we need to account
@@ -523,8 +662,6 @@ thread_fork(const char *name,
 	/* Set up the switchframe so entrypoint() gets called */
 	switchframe_init(newthread, entrypoint, data1, data2);
 
-	/* Lock the current cpu's run queue and make the new thread runnable */
-	thread_make_runnable(newthread, false);
 
 	/*
 	 * Return new thread structure if it's wanted. Note that using
@@ -536,6 +673,10 @@ thread_fork(const char *name,
 		*ret = newthread;
 	}
 
+	/* Lock the current cpu's run queue and make the new thread runnable */
+	thread_make_runnable(newthread, false);
+
+
 	return 0;
 }
 
@@ -800,6 +941,16 @@ thread_exit(void)
 		cur->t_cwd = NULL;
 	}
 
+	/**
+	 * Author:Pratham Malik
+	 * clearing the thread new variables added due to ASST2
+	 * and decreasing the reference count for parent thread
+	 */
+
+
+
+	//End of additions by PM
+
 	/* VM fields */
 	if (cur->t_addrspace) {
 		/*
@@ -1070,7 +1221,8 @@ wchan_wakeone(struct wchan *wc)
 		/* Nobody was sleeping. */
 		return;
 	}
-
+	DEBUG(DB_THREADS,
+				      "Waking thread UP");
 	thread_make_runnable(target, false);
 }
 
@@ -1108,6 +1260,8 @@ wchan_wakeall(struct wchan *wc)
 		thread_make_runnable(target, false);
 	}
 
+	DEBUG(DB_THREADS,
+					      "Waking All threads UP");
 	threadlist_cleanup(&list);
 }
 
diff --git a/submit.patch b/submit.patch
new file mode 100644
index 0000000..c6f5265
--- /dev/null
+++ b/submit.patch
@@ -0,0 +1,2718 @@
+diff --git a/kern/arch/mips/conf/ldscript b/kern/arch/mips/conf/ldscript
+index cbe86ac..ba44f70 100644
+--- a/kern/arch/mips/conf/ldscript
++++ b/kern/arch/mips/conf/ldscript
+@@ -1,3 +1,4 @@
++
+ /*
+  * This is a pile of crap that tells the linker how to link the kernel,
+  * because it's too stupid to be able to work it out on its own.
+diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
+index ff39633..cb2b6a0 100644
+--- a/kern/arch/mips/locore/trap.c
++++ b/kern/arch/mips/locore/trap.c
+@@ -39,7 +39,8 @@
+ #include <vm.h>
+ #include <mainbus.h>
+ #include <syscall.h>
+-
++#include <../../../include/psyscall.h>
++#include <../../../include/kern/wait.h>
+ 
+ /* in exception.S */
+ extern void asm_usermode(struct trapframe *tf);
+@@ -114,7 +115,24 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
+ 
+ 	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
+ 		code, sig, trapcodenames[code], epc, vaddr);
+-	panic("I don't know how to handle this\n");
++
++
++		sys___exit(0);
++//Added by Pratham Malik
++
++/*
++		pid_t pid_process=curthread->t_pid;
++
++		//Store the exit code passed in the argument
++		process_array[pid_process]->exit_code= 0;
++
++		//Indicate Exit by calling changing the exit status in the process array
++		process_array[pid_process]->exit_status=true;
++
++		thread_exit();
++*/
++//End of Additions by PM
++//	panic("I don't know how to handle this\n");
+ }
+ 
+ /*
+diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
+index 0f773bd..1117b51 100644
+--- a/kern/arch/mips/syscall/syscall.c
++++ b/kern/arch/mips/syscall/syscall.c
+@@ -35,6 +35,7 @@
+ #include <thread.h>
+ #include <current.h>
+ #include <syscall.h>
++#include <file_syscall.h>
+ 
+ 
+ /*
+@@ -80,6 +81,7 @@ syscall(struct trapframe *tf)
+ {
+ 	int callno;
+ 	int32_t retval;
++	int32_t ret_value;
+ 	int err;
+ 
+ 	KASSERT(curthread != NULL);
+@@ -96,9 +98,12 @@ syscall(struct trapframe *tf)
+ 	 * deal with it except for calls that return other values, 
+ 	 * like write.
+ 	 */
++//		kprintf("\nsyscall %d\n", callno);
+ 
+ 	retval = 0;
+ 
++	ret_value=0;
++	int64_t lseek_variable=0;
+ 	switch (callno) {
+ 	    case SYS_reboot:
+ 		err = sys_reboot(tf->tf_a0);
+@@ -109,8 +114,71 @@ syscall(struct trapframe *tf)
+ 				 (userptr_t)tf->tf_a1);
+ 		break;
+ 
+-	    /* Add stuff here */
++	    case SYS_open:
++	    	err= sys_open((userptr_t)tf->tf_a0,
++	    			tf->tf_a1, &retval);
++	    break;
++
++	    case SYS_close:
++	    	err= sys_close(tf->tf_a0);
++	    break;
++
++	    case SYS_read:
++	    	err= sys_read(tf->tf_a0, (userptr_t)tf->tf_a1,
++	    			tf->tf_a2, &retval);
++	    break;
++	    case SYS_write:
++	    err= sys_write(tf->tf_a0, (userptr_t)tf->tf_a1,
++	    		tf->tf_a2, &retval);
++	    break;
++
++	    case SYS_dup2:
++	    err= dup2(tf->tf_a0,tf->tf_a1, &retval);
++	    break;
++
++	    case SYS___getcwd:
++	    err= __getcwd((userptr_t)tf->tf_a0,
++	    		tf->tf_a1, &retval);
++	    break;
++
++	    case SYS_chdir:
++	    	err= chdir((userptr_t)tf->tf_a0);
++	     break;
++
++	    case SYS_lseek:
++	    	lseek_variable= (int64_t)tf->tf_a2 << 32 | tf->tf_a3;
++	    	err= lseek(tf->tf_a0, lseek_variable, tf->tf_sp+16, &retval, &ret_value);
++	    break;
++
++	    /* Add stuff
++	     *  here */
+  
++
++	    /* Add stuff here */
++
++
++	    case SYS_getpid:
++		err = sys___getpid(&retval);
++		break;
++
++	    case SYS__exit:
++	    err = sys___exit(tf->tf_a0);
++	    break;
++
++	    case SYS_waitpid:
++	    err = sys___waitpid(tf->tf_a0,(userptr_t)tf->tf_a1,tf->tf_a2,&retval);
++	    break;
++
++	    case SYS_fork:
++	    err = sys___fork(tf,&retval);
++	    break;
++
++
++	    case SYS_execv:
++	    err = sys___execv((userptr_t)tf->tf_a0,(userptr_t)tf->tf_a1);
++	    break;
++
++
+ 	    default:
+ 		kprintf("Unknown syscall %d\n", callno);
+ 		err = ENOSYS;
+@@ -130,6 +198,7 @@ syscall(struct trapframe *tf)
+ 	else {
+ 		/* Success. */
+ 		tf->tf_v0 = retval;
++		tf->tf_v1= ret_value;
+ 		tf->tf_a3 = 0;      /* signal no error */
+ 	}
+ 	
+@@ -153,9 +222,10 @@ syscall(struct trapframe *tf)
+  * both it and the code that calls it.
+  *
+  * Thus, you can trash it and do things another way if you prefer.
+- */
++ *
+ void
+ enter_forked_process(struct trapframe *tf)
+ {
+ 	(void)tf;
+ }
++*/
+diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
+index d527f61..0c1bd8c 100644
+--- a/kern/conf/conf.kern
++++ b/kern/conf/conf.kern
+@@ -367,6 +367,9 @@ file      vfs/devnull.c
+ file      syscall/loadelf.c
+ file      syscall/runprogram.c
+ file      syscall/time_syscalls.c
++file      syscall/file_syscall.c
++file      syscall/psyscall.c
++
+ 
+ #
+ # Startup and initialization
+diff --git a/kern/include/file_syscall.h b/kern/include/file_syscall.h
+new file mode 100644
+index 0000000..80f9a94
+--- /dev/null
++++ b/kern/include/file_syscall.h
+@@ -0,0 +1,40 @@
++/*
++ * file_syscall.h
++ *
++ *  Created on: Mar 1, 2015
++ *      Author: trinity
++ */
++
++#ifndef FILE_SYSCALL_H_
++#define FILE_SYSCALL_H_
++
++
++struct vnode;
++struct lock;
++
++struct file_descriptor{
++	char *f_name;
++	int f_flag;
++	off_t f_offset;
++	struct lock *f_lock;
++	struct vnode *f_object;
++	int reference_count;
++};
++
++int intialize_file_desc_tbl(struct file_descriptor *file_table[]);
++struct file_descriptor* intialize_file_desc_con(struct vnode *v, int index, char *file_name, int open_type);
++struct file_descriptor* file_descriptor_init(char *name);
++void file_descriptor_cleanup(struct file_descriptor *fd);
++int sys_open(userptr_t filename, int flags, int *return_val);
++int sys_close(int fd);
++int sys_read(int fd, userptr_t buf, size_t buflen, int *return_value);
++int sys_write(int fd, userptr_t buf, size_t nbytes, int *return_value);
++int dup2(int oldfd, int newfd, int *return_value);
++int __getcwd(userptr_t buf, size_t buflen, int *return_value);
++int chdir(userptr_t pathname);
++int lseek(int fd, off_t pos, int32_t whence, int32_t *return_value1, int32_t *return_value2);
++
++
++
++
++#endif /* FILE_SYSCALL_H_ */
+diff --git a/kern/include/kern/limits.h b/kern/include/kern/limits.h
+index 3fad3f2..51a12c5 100644
+--- a/kern/include/kern/limits.h
++++ b/kern/include/kern/limits.h
+@@ -71,6 +71,8 @@
+ /* Max bytes for atomic pipe I/O -- see description in the pipe() man page */
+ #define __PIPE_BUF      512
+ 
++/* Max value for a processes (Maximum number of user process that can run) */
++#define __PROCESS_MAX       512
+ 
+ /*
+  * Not so important parts of the API.
+diff --git a/kern/include/limits.h b/kern/include/limits.h
+index 01684c4..1bc3c28 100644
+--- a/kern/include/limits.h
++++ b/kern/include/limits.h
+@@ -48,5 +48,10 @@
+ #define LOGIN_NAME_MAX  __LOGIN_NAME_MAX
+ #define OPEN_MAX        __OPEN_MAX
+ #define IOV_MAX         __IOV_MAX
++/**
++ * Author Pratham Malik
++ */
++#define PROCESS_MAX         __PROCESS_MAX
++
+ 
+ #endif /* _LIMITS_H_ */
+diff --git a/kern/include/psyscall.h b/kern/include/psyscall.h
+new file mode 100644
+index 0000000..2dd045c
+--- /dev/null
++++ b/kern/include/psyscall.h
+@@ -0,0 +1,81 @@
++#ifndef _PSYSCALL_H_
++#define _PSYSCALL_H_
++
++#include <types.h>
++#include <thread.h>
++#include <limits.h>
++
++
++struct trapframe;
++struct thread;
++
++/**
++ * Declared array for pid tracking
++ */
++extern struct process_control *process_array[PROCESS_MAX];
++extern struct lock *pid_lock;
++/**
++* Structure for Process Control
++*/
++struct process_control
++{
++	/* process pid */
++
++	pid_t parent_id;
++	bool exit_status;
++	int exit_code;
++
++	struct thread *mythread;
++
++	//Child Process
++	struct child_process *childlist;
++
++	//Semaphore to synchronize the the exit status
++	struct semaphore *process_sem;
++
++	bool waitstatus;
++	struct lock *process_lock;
++	struct cv *process_cv;
++};
++
++struct child_process{
++
++	pid_t child_pid;
++	struct child_process *next;
++};
++
++/* Function to allocate pid to the thread and initialize the contents of Process structure*/
++
++pid_t
++allocate_pid(void);
++
++void
++initialize_pid(struct thread *thr,pid_t processid);
++
++int
++sys___getpid(int32_t *retval);
++
++int
++sys___exit(int);
++
++int
++sys___waitpid(int ,userptr_t ,int ,int32_t *retval);
++
++int
++sys___kwaitpid(int ,int *status,int ,int32_t *retval);
++
++
++
++void
++deallocate_pid(pid_t processid);
++
++int
++sys___fork(struct trapframe *tf,pid_t  *returnval);
++
++void
++enter_process(void *tf,unsigned long addr);
++
++int
++sys___execv(userptr_t ,userptr_t);
++
++#endif /* _PSYSCALL_H_ */
+diff --git a/kern/include/synch.h b/kern/include/synch.h
+index ac3714b..8a53033 100644
+--- a/kern/include/synch.h
++++ b/kern/include/synch.h
+@@ -29,7 +29,7 @@
+ 
+ #ifndef _SYNCH_H_
+ #define _SYNCH_H_
+-
++#define MAX_READ 500
+ /*
+  * Header file for synchronization primitives.
+  */
+@@ -74,6 +74,10 @@ void V(struct semaphore *);
+  */
+ struct lock {
+         char *lk_name;
++        struct wchan *lock_wchan;
++        volatile int lock_hold;
++        struct spinlock lk_spinlock;
++        struct thread *lk_thread;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -113,6 +117,7 @@ void lock_destroy(struct lock *);
+ 
+ struct cv {
+         char *cv_name;
++        struct wchan *cv_wchan;
+         // add what you need here
+         // (don't forget to mark things volatile as needed)
+ };
+@@ -143,6 +148,10 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
+ 
+ struct rwlock {
+         char *rwlock_name;
++        struct semaphore *rwlock_semaphore;
++        //struct wchan *rw_wchan;
++        //bool writer_inside;
++        struct lock *rwlock_lock;
+ };
+ 
+ struct rwlock * rwlock_create(const char *);
+diff --git a/kern/include/syscall.h b/kern/include/syscall.h
+index befd3d8..e46cf78 100644
+--- a/kern/include/syscall.h
++++ b/kern/include/syscall.h
+@@ -31,6 +31,10 @@
+ #define _SYSCALL_H_
+ 
+ 
++#include <file_syscall.h>
++#include <psyscall.h>
++
++
+ struct trapframe; /* from <machine/trapframe.h> */
+ 
+ /*
+diff --git a/kern/include/test.h b/kern/include/test.h
+index 240d583..5f9d0fa 100644
+--- a/kern/include/test.h
++++ b/kern/include/test.h
+@@ -105,8 +105,15 @@ int mallocstress(int, char **);
+ int nettest(int, char **);
+ 
+ /* Routine for running a user-level program. */
+-int runprogram(char *progname);
++//int runprogram(char *progname);
++/**
++ * Author: Pratham Malik
++ * adding arguments parameter for runprogram
++ */
++
++int runprogram(char *progname, char **);
+ 
++//End of additions by PM
+ /* Kernel menu system. */
+ void menu(char *argstr);
+ 
+diff --git a/kern/include/thread.h b/kern/include/thread.h
+index 86706ca..5c24d00 100644
+--- a/kern/include/thread.h
++++ b/kern/include/thread.h
+@@ -38,6 +38,9 @@
+ 
+ #include <spinlock.h>
+ #include <threadlist.h>
++#include <file_syscall.h>
++#include <limits.h>
++
+ 
+ struct addrspace;
+ struct cpu;
+@@ -65,6 +68,8 @@ typedef enum {
+ 	S_ZOMBIE,	/* zombie; exited but not yet deleted */
+ } threadstate_t;
+ 
++
++
+ /* Thread structure. */
+ struct thread {
+ 	/*
+@@ -112,6 +117,21 @@ struct thread {
+ 	struct vnode *t_cwd;		/* current working directory */
+ 
+ 	/* add more here as needed */
++
++	/*Added By Mohit
++	 * started
++	 */
++	struct file_descriptor *file_table[__OPEN_MAX];
++	/* Ended */
++
++
++	/*
++	 * Author: Pratham Malik
++	 * Added Process id variable for every thread
++	 */
++	pid_t t_pid;
++	//End of additions by PM
++
+ };
+ 
+ /* Call once during system startup to allocate data structures. */
+@@ -135,6 +155,7 @@ void thread_shutdown(void);
+  * thread should be done only with caution, because in general the
+  * child thread might exit at any time.) Returns an error code.
+  */
++
+ int thread_fork(const char *name, 
+                 void (*func)(void *, unsigned long),
+                 void *data1, unsigned long data2, 
+diff --git a/kern/startup/main.c b/kern/startup/main.c
+index be4c4b8..68723b7 100644
+--- a/kern/startup/main.c
++++ b/kern/startup/main.c
+@@ -30,6 +30,7 @@
+ /*
+  * Main.
+  */
++// "Adding for git" marora3@buffalo.edu
+ 
+ #include <types.h>
+ #include <kern/errno.h>
+@@ -50,11 +51,10 @@
+ #include <version.h>
+ #include "autoconf.h"  // for pseudoconfig
+ 
+-
+ /*
+  * These two pieces of data are maintained by the makefiles and build system.
+  * buildconfig is the name of the config file the kernel was configured with.
+- * buildversion starts at 1 and is incremented every time you link a kernel. 
++ * buildversion starts at 1 and is incremented every time you link a kernel.
+  *
+  * The purpose is not to show off how many kernels you've linked, but
+  * to make it easy to make sure that the kernel you just booted is the
+@@ -100,16 +100,19 @@ boot(void)
+ 	kprintf("%s", harvard_copyright);
+ 	kprintf("\n");
+ 
+-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
++	kprintf("prathamm@buffalo.edu's system version %s (%s #%d)\n",
+ 		GROUP_VERSION, buildconfig, buildversion);
+ 	kprintf("\n");
+ 
++
+ 	/* Early initialization. */
+ 	ram_bootstrap();
+ 	thread_bootstrap();
+ 	hardclock_bootstrap();
+ 	vfs_bootstrap();
+ 
++
++
+ 	/* Probe and initialize devices. Interrupts should come on. */
+ 	kprintf("Device probe...\n");
+ 	KASSERT(curthread->t_curspl > 0);
+diff --git a/kern/startup/menu.c b/kern/startup/menu.c
+index 6c71551..5d1ec8c 100644
+--- a/kern/startup/menu.c
++++ b/kern/startup/menu.c
+@@ -100,13 +100,15 @@ cmd_progthread(void *ptr, unsigned long nargs)
+ 
+ 	strcpy(progname, args[0]);
+ 
+-	result = runprogram(progname);
++	result = runprogram(progname,args);
+ 	if (result) {
+ 		kprintf("Running program %s failed: %s\n", args[0],
+ 			strerror(result));
+ 		return;
+ 	}
+ 
++	sys___exit(0);
++
+ 	/* NOTREACHED: runprogram only returns on error. */
+ }
+ 
+@@ -133,15 +135,44 @@ common_prog(int nargs, char **args)
+ 		"synchronization-problems kernel.\n");
+ #endif
+ 
++	/**
++	 * Author: Pratham Malik
++	 * Changing thread
++	 */
++
++	struct thread *childthr;
++	pid_t child_pid;
++
+ 	result = thread_fork(args[0] /* thread name */,
+ 			cmd_progthread /* thread function */,
+ 			args /* thread arg */, nargs /* thread arg */,
+-			NULL);
++			&childthr);
+ 	if (result) {
+ 		kprintf("thread_fork failed: %s\n", strerror(result));
+ 		return result;
+ 	}
+ 
++	child_pid = childthr->t_pid;
++
++
++ 	int status;
++	int32_t retval;
++
++//	status = kmalloc(sizeof(userptr_t));
++	result = sys___kwaitpid(child_pid,&status,0,&retval);
++	if(result)
++		return result;
++
++
++
++
++/*
++	result = thread_fork(args[0]  thread name ,
++			cmd_progthread  thread function ,
++			args  thread arg , nargs  thread arg ,
++			NULL);
++*/
++
+ 	return 0;
+ }
+ 
+diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
+index 81d2f0e..ccf4ee2 100644
+--- a/kern/synchprobs/problems.c
++++ b/kern/synchprobs/problems.c
+@@ -46,15 +46,42 @@
+ // 13 Feb 2012 : GWA : Adding at the suggestion of Isaac Elbaz. These
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
++struct cv *cv_male;
++struct cv *cv_female;
++struct cv *cv_matchmaker;
++
++
++static volatile int male_count,female_count,matchmaker_count;
++struct lock *matching_lock;
++
++
+ 
+ void whalemating_init() {
+-  return;
++  /*
++   * Author: Student
++   * Declaring semaphores for male,female and matchmaker
++   *
++   */
++	cv_male= cv_create("male");
++	cv_female=cv_create("female");
++	cv_matchmaker=cv_create("matchmaker");
++	matching_lock= lock_create("matching_lock");
++	male_count=0;
++	female_count=0;
++	matchmaker_count=0;
++
++	return;
+ }
+ 
+ // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void whalemating_cleanup() {
++
++	cv_destroy(cv_male);
++	cv_destroy(cv_female);
++	cv_destroy(cv_matchmaker);
++	lock_destroy(matching_lock);
+   return;
+ }
+ 
+@@ -62,11 +89,53 @@ void
+ male(void *p, unsigned long which)
+ {
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+-  (void)which;
+-  
+-  male_start();
+-	// Implement this function 
+-  male_end();
++	(void)which;
++
++
++	  male_start();
++	  lock_acquire(matching_lock);
++	  male_count++;
++
++	  if(female_count==0 || matchmaker_count ==0){
++		  cv_wait(cv_male, matching_lock);
++		  male_end();
++	  }
++	  else if(female_count>0 && matchmaker_count >0){
++		 while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
++		 		  if(cv_male->cv_wchan != NULL){
++		 			 cv_signal(cv_male, matching_lock);
++		 			 male_count--;
++		 			 cv_signal(cv_female, matching_lock);
++		 			 cv_signal(cv_matchmaker, matching_lock);
++
++		 		  }
++		 		  else{
++		 			 cv_signal(cv_female, matching_lock);
++		 			 cv_signal(cv_matchmaker, matching_lock);
++		 			 male_count--;
++		 		  }
++
++		 		  male_end();
++
++		 	  }
++	  }
++
++
++
++	  lock_release(matching_lock);
++
++
++
++	// Implement this function
++  /*
++   * Author: Student
++   * Implementing the semaphore for male
++   */
++
++
++//male_end();
++
++
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+@@ -79,11 +148,42 @@ female(void *p, unsigned long which)
+ {
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+-  
++
+   female_start();
+-	// Implement this function 
+-  female_end();
+-  
++
++  lock_acquire(matching_lock);
++  	  female_count++;
++  	  if(male_count ==0 || matchmaker_count== 0){
++  		  cv_wait(cv_female, matching_lock);
++  		female_end();
++  	  }
++  	  else if(male_count>0 && matchmaker_count >0){
++  		while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
++  		  		  if(cv_female->cv_wchan!= NULL){
++  		  			  cv_signal(cv_male, matching_lock);
++  		  			  male_count--;
++  		  			  cv_signal(cv_female, matching_lock);
++  		  			  female_count--;
++  		  			  cv_signal(cv_matchmaker, matching_lock);
++  		  			  matchmaker_count--;
++
++  		  		  }
++  		  		  else{
++  		  			  cv_signal(cv_male, matching_lock);
++  		  			  male_count--;
++  		  			  cv_signal(cv_matchmaker, matching_lock);
++  		  			  matchmaker_count--;
++  		  			  female_count--;
++  		  		  }
++
++  		  		female_end();
++
++  		  	  }
++  	  }
++
++
++  	  lock_release(matching_lock);
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+@@ -95,17 +195,50 @@ matchmaker(void *p, unsigned long which)
+ {
+ 	struct semaphore * whalematingMenuSemaphore = (struct semaphore *)p;
+   (void)which;
+-  
++
+   matchmaker_start();
+-	// Implement this function 
+-  matchmaker_end();
+-  
++  lock_acquire(matching_lock);
++  	  matchmaker_count++;
++    	  if(male_count ==0 || female_count==0){
++    		  cv_wait(cv_matchmaker, matching_lock);
++    		  matchmaker_end();
++    	  }
++    	  else if(male_count>0 && female_count >0){
++    		  while(!(male_count== 0 || female_count== 0 || matchmaker_count ==0)){
++    		      if(cv_matchmaker->cv_wchan!= NULL){
++    		         cv_signal(cv_male, matching_lock);
++    		         male_count--;
++    		         cv_signal(cv_female, matching_lock);
++    		         female_count--;
++    		         cv_signal(cv_matchmaker, matching_lock);
++    		         matchmaker_count--;
++
++    		      }
++    		      else{
++    		        cv_signal(cv_male, matching_lock);
++    		        male_count--;
++    		        cv_signal(cv_female, matching_lock);
++    		        female_count--;
++    		      	matchmaker_count--;
++    		      }
++
++        		  matchmaker_end();
++    		  }
++    	  }
++
++
++    	  lock_release(matching_lock);
++  //matchmaker_end();
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // whalemating driver can return to the menu cleanly.
+   V(whalematingMenuSemaphore);
+   return;
+ }
+ 
++
++
++
+ /*
+  * You should implement your solution to the stoplight problem below. The
+  * quadrant and direction mappings for reference: (although the problem is,
+@@ -137,7 +270,22 @@ matchmaker(void *p, unsigned long which)
+ // functions will allow you to do local initialization. They are called at
+ // the top of the corresponding driver code.
+ 
++struct cv * cross_intersection;
++struct lock * lock_intersection;
++bool status_busy;
++static volatile int quadrant[4];	//To signify which parts of the quadrant one is occupying, 0 signifies free and 1 signifies taken
++
+ void stoplight_init() {
++
++	cross_intersection= cv_create("cross0");
++
++
++	lock_intersection= lock_create("intersection_lock");
++	status_busy=false;
++	quadrant[0]=0;
++	quadrant[1]=0;
++	quadrant[2]=0;
++	quadrant[3]=0;
+   return;
+ }
+ 
+@@ -145,6 +293,9 @@ void stoplight_init() {
+ // care if your problems leak memory, but if you do, use this to clean up.
+ 
+ void stoplight_cleanup() {
++	cv_destroy(cross_intersection);
++
++	lock_destroy(lock_intersection);
+   return;
+ }
+ 
+@@ -153,7 +304,35 @@ gostraight(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++  /*
++   * Author: Student
++   */
+   
++  lock_acquire(lock_intersection);
++
++  while(!(quadrant[direction]==0 && (quadrant[(direction+3)%4]==0))){
++	  cv_wait(cross_intersection,lock_intersection);
++
++  }//End of while
++
++  quadrant[direction]=1;
++  quadrant[(direction+3)%4]=1;
++
++  lock_release(lock_intersection);
++
++  inQuadrant(direction);
++  inQuadrant((direction+3)%4);
++  leaveIntersection();
++
++  lock_acquire(lock_intersection);
++  quadrant[direction]=0;
++  quadrant[(direction+3)%4]=0;
++
++	cv_signal(cross_intersection,lock_intersection);
++
++  lock_release(lock_intersection);
++
++
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+   V(stoplightMenuSemaphore);
+@@ -165,6 +344,37 @@ turnleft(void *p, unsigned long direction)
+ {
+ 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
+   (void)direction;
++
++  /*
++   *  Author: Student
++     */
++
++  lock_acquire(lock_intersection);
++  while(!(quadrant[direction]==0 && (quadrant[(direction+3)%4]==0)&& (quadrant[(direction+2)%4]==0))){
++	  cv_wait(cross_intersection,lock_intersection);
++  }//End of while
++
++  quadrant[direction]=1;
++  quadrant[(direction+3)%4]=1;
++  quadrant[(direction+2)%4]=1;
++
++  lock_release(lock_intersection);
++
++  inQuadrant(direction);
++  inQuadrant((direction+3)%4);
++  inQuadrant((direction+2)%4);
++  leaveIntersection();
++
++  lock_acquire(lock_intersection);
++  quadrant[direction]=0;
++  quadrant[(direction+3)%4]=0;
++  quadrant[(direction+2)%4]=0;
++
++	cv_signal(cross_intersection,lock_intersection);
++
++  lock_release(lock_intersection);
++
++
+   
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
+@@ -180,6 +390,31 @@ turnright(void *p, unsigned long direction)
+ 
+   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
+   // stoplight driver can return to the menu cleanly.
++
++  /*
++   *  Author: Student
++     */
++
++  lock_acquire(lock_intersection);
++
++  while(!(quadrant[direction]==0)){
++	  cv_wait(cross_intersection,lock_intersection);
++  }//End of while
++
++  quadrant[direction]=1;
++
++  lock_release(lock_intersection);
++
++  inQuadrant(direction);
++  leaveIntersection();
++
++  lock_acquire(lock_intersection);
++  quadrant[direction]=0;
++
++	cv_signal(cross_intersection,lock_intersection);
++
++  lock_release(lock_intersection);
++
+   V(stoplightMenuSemaphore);
+   return;
+ }
+diff --git a/kern/syscall/file_syscall.c b/kern/syscall/file_syscall.c
+new file mode 100644
+index 0000000..ac74f6f
+--- /dev/null
++++ b/kern/syscall/file_syscall.c
+@@ -0,0 +1,494 @@
++/*
++ * file_syscall.c
++ *
++ *  Created on: Mar 1, 2015
++ *      Author: trinity
++ *
++ *      Added By Mohit
++ */
++#include <limits.h>
++#include <types.h>
++#include <kern/errno.h>
++#include <kern/fcntl.h>
++#include <file_syscall.h>
++#include <current.h>
++#include <lib.h>
++#include <synch.h>
++#include <copyinout.h>
++#include <vfs.h>
++#include <uio.h>
++#include <vnode.h>
++#include <stat.h>
++#include <kern/unistd.h>
++#include <kern/seek.h>
++
++
++struct file_descriptor*
++file_descriptor_init(char *name)
++{
++	struct file_descriptor *fd;
++
++		fd = kmalloc(sizeof(struct file_descriptor));
++		if(fd==NULL){
++			return NULL;
++		}
++
++		fd->f_name=kstrdup(name);
++		if(fd->f_name==NULL){
++			kfree(fd);
++			return NULL;
++		}
++
++		fd->f_lock=lock_create(fd->f_name);
++		   	if (fd->f_lock == NULL) {
++		   		kfree(fd->f_lock);
++		   		kfree(fd);
++			    return NULL;
++		}
++
++	return fd;
++
++}
++void
++file_descriptor_cleanup(struct file_descriptor *fd)
++{
++	KASSERT(fd != NULL);
++	lock_destroy(fd->f_lock);
++	kfree(fd->f_name);
++	kfree(fd);
++}
++
++int
++intialize_file_desc_tbl(struct file_descriptor *file_table[]){
++
++
++	char filename[5]= "con:";
++
++	int result;
++	char con_name_in[5];
++	strcpy(con_name_in, filename);
++	struct vnode *v;
++	result= vfs_open(con_name_in, STDIN_FILENO ,0664, &v);
++	if(result){
++		return result;
++	}
++	struct file_descriptor* fd_in;
++	fd_in = intialize_file_desc_con(v, 0, filename, STDIN_FILENO);
++	file_table[0]=fd_in;
++	vfs_close(v);
++
++
++	char con_name_out[5];
++	strcpy(con_name_out, filename);
++	result= vfs_open(con_name_out, STDOUT_FILENO ,0664, &v);
++	if(result){
++		return result;
++	}
++	struct file_descriptor* fd_out;
++	fd_out = intialize_file_desc_con(v, 0, filename, STDOUT_FILENO);
++	file_table[1]=fd_out;
++	vfs_close(v);
++
++	char con_name_err[5];
++	strcpy(con_name_err, filename);
++	result= vfs_open(con_name_err, STDERR_FILENO ,0664, &v);
++	if(result){
++		return result;
++	}
++	struct file_descriptor* fd_err;
++	fd_err = intialize_file_desc_con(v, 0, filename, STDERR_FILENO);
++	file_table[2]=fd_err;
++	vfs_close(v);
++
++	for(int i=3; i<__OPEN_MAX;i++){
++		file_table[i]=0;
++	}
++return 0;
++
++}
++struct file_descriptor*
++intialize_file_desc_con(struct vnode *v, int index, char *file_name, int open_type){
++	struct file_descriptor *fd;
++	fd= file_descriptor_init(file_name);
++	lock_acquire(fd->f_lock);
++	fd->f_flag= open_type;		//fd.f_name= k_des;
++	fd->f_object= v;
++	fd->f_offset=0;
++	fd->reference_count=1;
++	curthread->file_table[index]=fd;
++	lock_release(fd->f_lock);
++return fd;
++}
++
++int
++sys_open(userptr_t filename, int flags, int *return_val)   /*Done using copyinstr as said in blog*/
++{
++	struct file_descriptor *fd;
++	struct vnode *vn;
++	int result;
++	struct stat st;
++	/*void des;
++	size_t length;
++	if((result=copyin((const_userptr_t)filename, &des, length ))!= 0){
++			return result;
++	}*/
++	char k_des[NAME_MAX];
++	size_t actual_length;
++	if((result=copyinstr((const_userptr_t)filename, k_des, NAME_MAX, &actual_length ))!= 0){
++		return result;
++	}
++	char *file_name= k_des;
++		for(int i=3; i<__OPEN_MAX;i++){
++			if(curthread->file_table[i]==  0){
++				if((flags&O_ACCMODE)== O_RDONLY){
++					result= vfs_open(k_des, flags, 0, &vn);
++				}
++				else if((flags&O_ACCMODE)== O_WRONLY){
++					result= vfs_open(k_des, flags, 0, &vn);
++				}
++				else if((flags&O_ACCMODE)== O_RDWR){
++					result= vfs_open(k_des, flags, 0, &vn);
++				}
++				else if((flags&O_APPEND)== O_APPEND){
++					result= vfs_open(k_des, flags, 0, &vn);
++					if(result){
++						return result;
++					}
++					result= VOP_STAT(vn, &st);
++					if(result){
++						return result;
++					}
++				}
++				else{
++					return EINVAL;
++				}
++				if(result){
++					return result;
++				}
++				fd= file_descriptor_init(file_name);
++				lock_acquire(fd->f_lock);
++				if((flags& O_APPEND)== O_APPEND){
++					fd->f_flag= O_APPEND;
++				}
++				else{
++					fd->f_flag= (flags&O_ACCMODE);
++				}
++
++				//fd.f_name= k_des;
++				fd->f_object= vn;
++					fd->f_offset=0;
++				//}
++				fd->reference_count=1;
++				*return_val= i;
++				curthread->file_table[i]=fd;
++				lock_release(fd->f_lock);
++
++				break;
++			}
++		}
++return 0;
++}
++
++int
++sys_close(int fd){						/*I have done KFREE not sure, whether we have to use this or not, Just confirm once again*/
++
++  	if(fd <0 || fd>=__OPEN_MAX){
++			return EBADF;
++	}
++	struct file_descriptor *fd_frm_table;
++	struct vnode *vn;
++	fd_frm_table= curthread->file_table[fd];
++	if(fd_frm_table ==0 ){
++		return EBADF;
++	}
++	lock_acquire(fd_frm_table->f_lock);
++	fd_frm_table->reference_count--;
++	if(fd_frm_table->reference_count == 0){
++		vn= fd_frm_table->f_object;
++		vfs_close(vn);
++		lock_release(fd_frm_table->f_lock);
++		file_descriptor_cleanup(fd_frm_table);
++		//&return_value= 0;
++		curthread->file_table[fd]=0;
++		return 0;
++	}
++	lock_release(fd_frm_table->f_lock);
++	//&return_value=0;
++	return 0;
++}
++
++/*Dont know how to check whether buf is valid address space or not
++ *Need to do that
++ *
++ *
++ *Getting the corresponding file_descriptor object from the table and using to read the data from the file
++ *It means that file need to be open before read
++ *
++ *Saw the code mainly from loadelf.c and rest read the blog and implemented
++ */
++
++int
++sys_read(int fd, userptr_t buf, size_t buflen, int *return_value){
++
++
++
++
++	int result;
++	void* kbuf = kmalloc(buflen);
++	if ((result = copyin((const_userptr_t)buf, kbuf, buflen)) != 0){
++		kfree(kbuf);
++		return result;
++	}
++
++	if(fd <0 || fd>=__OPEN_MAX){
++		return EBADF;
++	}
++	struct file_descriptor *fd_frm_table;
++	struct vnode *vn;
++	struct iovec u_iovec;
++	struct uio u_uio;
++	fd_frm_table= curthread->file_table[fd];
++
++	if(fd_frm_table !=0 ){
++		lock_acquire(fd_frm_table->f_lock);
++		vn= fd_frm_table->f_object;
++
++		u_iovec.iov_ubase= buf;
++		u_iovec.iov_len= buflen;
++		u_uio.uio_iov= &u_iovec;
++		u_uio.uio_iovcnt= 1;
++		u_uio.uio_offset= fd_frm_table->f_offset;
++		u_uio.uio_resid= buflen;
++		u_uio.uio_segflg= UIO_USERSPACE;
++		u_uio.uio_rw= UIO_READ;
++		u_uio.uio_space= curthread->t_addrspace;
++
++		result= VOP_READ(vn, &u_uio);
++		if(result){
++			lock_release(fd_frm_table->f_lock);
++			return result;
++		}
++		else{
++			*return_value= (buflen-u_uio.uio_resid); /*Need to return the length left to read, I think*/
++			fd_frm_table->f_offset+= buflen-u_uio.uio_resid;
++			lock_release(fd_frm_table->f_lock);
++		}
++	}
++	else{
++		return EBADF;
++	}
++
++
++return 0;
++}
++/*
++ * There are some error codes that need to be returned but dont know whether to check them or not
++ */
++int
++sys_write(int fd, userptr_t buf, size_t nbytes, int *return_value){
++
++
++	int result;
++	void* kbuf = kmalloc(nbytes);
++	if ((result = copyin((const_userptr_t)buf, kbuf, nbytes)) != 0){
++		kfree(kbuf);
++		return result;
++	}
++	if(fd <0 || fd>=__OPEN_MAX){
++			return EBADF;
++	}
++	struct file_descriptor *fd_frm_table;
++	struct vnode *vn;
++	struct iovec u_iovec;
++	struct uio u_uio;
++	fd_frm_table= curthread->file_table[fd];
++	if(fd_frm_table != 0){
++		lock_acquire(fd_frm_table->f_lock);
++		if(!(fd_frm_table->f_flag == O_RDWR || fd_frm_table->f_flag == O_WRONLY)){
++			lock_release(fd_frm_table->f_lock);
++			return EROFS;
++		}
++
++		u_uio.uio_offset= fd_frm_table->f_offset;
++		vn= fd_frm_table->f_object;
++		u_iovec.iov_ubase= buf;
++		u_iovec.iov_len= nbytes;
++
++		u_uio.uio_iov= &u_iovec;
++		u_uio.uio_iovcnt= 1;
++
++		u_uio.uio_resid= nbytes;
++		u_uio.uio_rw= UIO_WRITE;
++		u_uio.uio_segflg= UIO_USERSPACE;
++		u_uio.uio_space= curthread->t_addrspace;
++
++		result= VOP_WRITE(vn, &u_uio);
++		if(result){
++			lock_release(fd_frm_table->f_lock);
++			return result;
++		}
++		else{
++			*return_value= (nbytes-u_uio.uio_resid);
++			fd_frm_table->f_offset+= nbytes-u_uio.uio_resid;
++			lock_release(fd_frm_table->f_lock);
++		}
++	}
++	else{
++		return EBADF;
++	}
++
++
++return 0;
++}
++
++int
++dup2(int oldfd, int newfd, int *return_value){
++
++	if(newfd<0 || newfd>=__OPEN_MAX || oldfd<0 || oldfd>=__OPEN_MAX){
++		return EBADF;
++	}
++	else{
++		struct file_descriptor *fd;
++		fd= curthread->file_table[oldfd];
++		if(fd==0){
++			return EBADF;
++		}
++		int count=0;
++		for(int i=3; i<__OPEN_MAX;i++){
++			if(curthread->file_table[i]!= 0){
++				count++;
++			}
++			else{
++				break;
++			}
++		}
++		if(count== __OPEN_MAX){
++			return EMFILE;
++		}
++		if(newfd != oldfd){
++			if(curthread->file_table[newfd]!= 0){
++				sys_close(newfd);
++			}
++			curthread->file_table[newfd]= fd;
++			fd->reference_count++;
++			*return_value= newfd;
++		}
++	}
++return 0;
++}
++
++int
++__getcwd(userptr_t buf, size_t buflen, int *return_value){
++	int result;
++	char k_des[PATH_MAX];
++	size_t actual_length;
++	if((result=copyinstr((const_userptr_t)buf, k_des, PATH_MAX, &actual_length ))!= 0){
++		return result;
++	}
++	struct uio u_uio;
++	struct iovec u_iovec;
++	u_iovec.iov_ubase= buf;
++	u_iovec.iov_len= buflen;
++
++	u_uio.uio_iov= &u_iovec;
++	u_uio.uio_iovcnt= 1;
++	u_uio.uio_offset=0;
++	u_uio.uio_resid= buflen;
++	u_uio.uio_rw= UIO_READ;
++	u_uio.uio_segflg= UIO_USERSPACE;
++	u_uio.uio_space= curthread->t_addrspace;
++
++	result = vfs_getcwd(&u_uio);
++	if (result) {
++		return result;
++	}
++	*return_value= u_uio.uio_resid;
++
++return 0;
++}
++
++int
++chdir(userptr_t pathname){
++	int result;
++	char k_des[PATH_MAX];
++	size_t actual_length;
++	if((result=copyinstr((const_userptr_t)pathname, k_des, PATH_MAX, &actual_length ))!= 0){
++		return result;
++	}
++	result= vfs_chdir(k_des);
++	if(result){
++		return result;
++	}
++
++return 0;
++}
++
++int
++lseek(int fd, off_t pos, int32_t whence, int32_t *return_value1, int32_t *return_value2){
++
++	if(fd <0 || fd>=__OPEN_MAX){
++		return EBADF;
++	}
++	struct file_descriptor *fd_frm_table;
++	fd_frm_table= curthread->file_table[fd];
++	if(fd_frm_table == 0){
++			return EBADF;
++	}
++	//int32_t *sz= &whence;
++	int* kbuf = kmalloc(sizeof(whence));
++	int result;
++	if ((result = copyin((const_userptr_t)whence, kbuf, sizeof(whence))) != 0){
++		kfree(kbuf);
++		return result;
++	}
++	struct vnode *vn;
++	struct stat st;
++	lock_acquire(fd_frm_table->f_lock);
++	vn= fd_frm_table->f_object;
++	int c_pos= fd_frm_table->f_offset;
++
++	if((*kbuf&O_ACCMODE)== SEEK_SET){
++		result= VOP_TRYSEEK(vn, pos);
++			if(result){
++				lock_release(fd_frm_table->f_lock);
++				return result;
++			}
++			fd_frm_table->f_offset= pos;
++
++	}
++	else if((*kbuf&O_ACCMODE)== SEEK_CUR){
++		result= VOP_TRYSEEK(vn, (pos+c_pos));
++			if(result){
++				lock_release(fd_frm_table->f_lock);
++				return result;
++			}
++			fd_frm_table->f_offset= pos+c_pos;
++	}
++	else if((*kbuf&O_ACCMODE)== SEEK_END){
++
++		result= VOP_STAT(vn, &st);
++		if(result){
++		lock_release(fd_frm_table->f_lock);
++		return result;
++		}
++		off_t eof= st.st_size;
++		result= VOP_TRYSEEK(vn, (pos+eof));
++		if(result){
++		lock_release(fd_frm_table->f_lock);
++		return result;
++		}
++		fd_frm_table->f_offset= pos+eof;
++	}
++	else{
++		return EINVAL;
++	}
++	int64_t final_value= fd_frm_table->f_offset;
++	int32_t high = (int32_t)((final_value & 0xFFFFFFFF00000000) >> 32);
++	int32_t low = (int32_t)(final_value & 0xFFFFFFFF);
++	*return_value1= high;
++	*return_value2= low;
++	lock_release(fd_frm_table->f_lock);
++
++
++return 0;
++}
+diff --git a/kern/syscall/psyscall.c b/kern/syscall/psyscall.c
+new file mode 100644
+index 0000000..e1531ac
+--- /dev/null
++++ b/kern/syscall/psyscall.c
+@@ -0,0 +1,532 @@
++
++#include <types.h>
++#include <clock.h>
++#include <copyinout.h>
++#include <lib.h>
++#include <limits.h>
++#include <thread.h>
++#include <current.h>
++#include <synch.h>
++#include <psyscall.h>
++#include <kern/errno.h>
++#include <addrspace.h>
++#include <mips/trapframe.h>
++#include <kern/wait.h>
++#include <kern/fcntl.h>
++#include <vm.h>
++#include <vfs.h>
++#include <syscall.h>
++#include <test.h>
++#include <file_syscall.h>
++
++
++
++void
++initialize_pid(struct thread *thr,pid_t processid)
++{
++	if(curthread!=NULL)
++		lock_acquire(pid_lock);
++	struct process_control *p_array;
++
++	p_array=kmalloc(sizeof(struct process_control));
++
++	thr->t_pid=processid;
++
++	p_array->parent_id=-1;
++	p_array->childlist=NULL;
++	p_array->exit_code=-1;
++	p_array->exit_status=false;
++	p_array->mythread=thr;
++	p_array->waitstatus=false;
++	p_array->process_sem = sem_create(thr->t_name,0);
++
++	//Create the lock and CV
++	p_array->process_lock=lock_create(thr->t_name);
++	p_array->process_cv = cv_create(thr->t_name);
++
++	//Copy back into the thread
++	process_array[processid]=p_array;
++
++	if(curthread!=NULL)
++		lock_release(pid_lock);
++
++}
++
++pid_t
++allocate_pid(void)
++{
++	for(int i=PID_MIN;i<PROCESS_MAX;i++)
++	{
++		if(process_array[i]==0)
++		{
++			return i;
++			break;
++		}
++	}
++	return -1;
++}
++
++void
++deallocate_pid(pid_t processid)
++{
++
++	if(process_array[processid]==0 || process_array[processid]==NULL)
++	{
++		//Do Nothing
++	}
++	else
++	{
++		pid_t parent_id = process_array[processid]->parent_id;
++		if(parent_id>PID_MIN)
++		{
++				int counter=0;
++				for(counter=3;counter<__OPEN_MAX;counter++)
++				{
++					if(curthread->file_table[counter]!=0)
++					{
++						process_array[parent_id]->mythread->file_table[counter]->reference_count--;
++					}
++					else
++					{
++							//newthread->file_table[counter]=0;
++					}
++				}
++		}
++
++		sem_destroy(process_array[processid]->process_sem);
++		lock_destroy(process_array[processid]->process_lock);
++		cv_destroy(process_array[processid]->process_cv);
++		kfree(process_array[processid]);
++		process_array[processid]=0;
++
++	}
++}
++
++int
++sys___exit(int exit_code)
++{
++	//Check whether the process calling exit has no children?
++
++	pid_t pid_process=curthread->t_pid;
++
++	//Check whether to indicate exit by calling cv_broadcast as well
++//	cv_broadcast(process_array[pid_process]->process_cv,process_array[pid_process]->process_lock);
++
++	//Now using a semaphore and V when the thread exits
++	if(process_array[pid_process]->waitstatus==true)
++	{
++		lock_acquire(process_array[pid_process]->process_lock);
++
++		//Indicate Exit by calling changing the exit status in the process array
++		process_array[pid_process]->exit_code= _MKWAIT_EXIT(exit_code);
++
++		process_array[pid_process]->exit_status=true;
++
++		cv_signal(process_array[pid_process]->process_cv,process_array[pid_process]->process_lock);
++
++		lock_release(process_array[pid_process]->process_lock);
++
++	}
++		//V(process_array[pid_process]->process_sem);
++	else
++	{
++		lock_acquire(process_array[pid_process]->process_lock);
++
++		//Store the exit code passed in the argument
++		process_array[pid_process]->exit_code= _MKWAIT_EXIT(exit_code);
++
++		//Indicate Exit by calling changing the exit status in the process array
++		process_array[pid_process]->exit_status=true;
++
++		lock_release(process_array[pid_process]->process_lock);
++
++	}
++
++	thread_exit();
++
++	return 0;
++}
++
++int
++sys___getpid(int32_t *retval)
++{
++	*retval = curthread->t_pid;
++	return 0;
++}
++
++int
++sys___waitpid(int processid,userptr_t  status,int options, int32_t *retval)
++{
++	//pid_t pid_process= (int32_t) processid;
++	int exit_code;
++	int result;
++
++//	userptr_t user_status;
++
++/*
++	if(processid<PID_MIN)
++		return ESRCH;
++*/
++
++	if( options!=0){
++		return EINVAL;
++	}
++	//Check whether the pid exists
++	if(processid<PID_MIN || process_array[processid]==0 ||process_array[processid]==NULL)
++	{
++		return ESRCH;
++	}
++
++	//CHeck if the status is not NULL
++	if(status==NULL)
++		return EFAULT;
++
++	if (processid < PID_MIN)
++		return EINVAL;
++
++	if(processid > PID_MAX)
++		return ESRCH;
++
++	if (processid == curthread->t_pid)
++		return ECHILD;
++
++	//TODO::Check whether the pid exists in your child list -- Complete after fork - Completed below
++	if(!(curthread->t_pid == process_array[processid]->parent_id))
++		return ECHILD;
++
++
++	if(process_array[processid]->exit_status==true)
++	{
++		lock_acquire(process_array[processid]->process_lock);
++
++		exit_code = process_array[processid]->exit_code;
++
++		lock_release(process_array[processid]->process_lock);
++
++		result = copyout(&exit_code,status,sizeof(userptr_t));
++		if(result)
++			return result;
++
++		//Destroy Child's Process Structure - Call deallocate_pid
++
++		*retval = processid;
++		deallocate_pid(processid);
++
++	}
++	else if(process_array[processid]->exit_status==false)
++	{
++		lock_acquire(process_array[processid]->process_lock);
++
++		process_array[processid]->waitstatus=true;
++		cv_wait(process_array[processid]->process_cv,process_array[processid]->process_lock);
++
++		//P(process_array[pid_process]->process_sem);
++		exit_code = process_array[processid]->exit_code;
++
++		lock_release(process_array[processid]->process_lock);
++
++		result = copyout(&exit_code,status,sizeof(userptr_t));
++			if(result)
++					return result;
++
++		//Destroy Child's Process Structure - Call deallocate_pid
++
++		*retval = processid;
++		deallocate_pid(processid);
++	}
++
++		return 0;
++}
++
++int
++sys___kwaitpid(int processid,int *status,int options, int32_t *retval)
++{
++	//pid_t pid_process= (int32_t) processid;
++	int exit_code;
++//	int result;
++
++//	userptr_t user_status;
++
++/*
++	if(processid<PID_MIN)
++		return ESRCH;
++*/
++
++	if( options!=0){
++		return EINVAL;
++	}
++	//Check whether the pid exists
++	if(processid<PID_MIN || process_array[processid]==0 ||process_array[processid]==NULL)
++	{
++		return ESRCH;
++	}
++
++	//CHeck if the status is not NULL
++	if(status==NULL)
++		return EFAULT;
++
++	if (processid < PID_MIN)
++		return EINVAL;
++
++	if(processid > PID_MAX)
++		return ESRCH;
++
++	if (processid == curthread->t_pid)
++		return ECHILD;
++
++	//TODO::Check whether the pid exists in your child list -- Complete after fork - Completed below
++	if(!(curthread->t_pid == process_array[processid]->parent_id))
++		return ECHILD;
++
++
++	if(process_array[processid]->exit_status==true)
++	{
++		lock_acquire(process_array[processid]->process_lock);
++
++		exit_code = process_array[processid]->exit_code;
++
++		lock_release(process_array[processid]->process_lock);
++
++		status = &exit_code;
++
++	/*	result = copyout(&exit_code,status,sizeof(userptr_t));
++		if(result)
++			return result;
++*/
++		//Destroy Child's Process Structure - Call deallocate_pid
++
++		*retval = processid;
++		deallocate_pid(processid);
++
++	}
++	else if(process_array[processid]->exit_status==false)
++	{
++		lock_acquire(process_array[processid]->process_lock);
++
++		process_array[processid]->waitstatus=true;
++		cv_wait(process_array[processid]->process_cv,process_array[processid]->process_lock);
++
++		//P(process_array[pid_process]->process_sem);
++		exit_code = process_array[processid]->exit_code;
++
++		lock_release(process_array[processid]->process_lock);
++
++		status = &exit_code;
++
++		/*result = copyout(&exit_code,status,sizeof(userptr_t));
++			if(result)
++					return result;
++*/
++		//Destroy Child's Process Structure - Call deallocate_pid
++
++		*retval = processid;
++		deallocate_pid(processid);
++	}
++
++		return 0;
++}
++
++
++
++/*
++ * Fork System Call:: Forks a new process
++ * Returns two values to child and Parent.
++
++*/
++struct sendthing
++{
++	struct addrspace *parentaddr;
++	struct trapframe *childtf;
++};
++int
++sys___fork(struct trapframe *tf, pid_t *returnval)
++{
++	int result;
++	struct thread *child;
++	struct trapframe *parent_tf;
++
++	parent_tf = kmalloc(sizeof(struct trapframe));
++	if(parent_tf==NULL)
++		return ENOMEM;
++
++	memcpy(parent_tf,tf,sizeof(struct trapframe));
++//	parent_tf=tf;
++
++	pid_t current_pid = curthread->t_pid;
++
++	unsigned long parent_pid;
++	parent_pid = (unsigned long) current_pid;
++
++	result = thread_fork(curthread->t_name,enter_process,parent_tf,parent_pid,&child);
++	if(result){
++	//	kfree(parent_tf);
++		if(process_array[child->t_pid] == 0 || process_array[child->t_pid] == NULL)
++		{
++			//Do Nothing
++		}
++		else
++		{
++			kfree(process_array[child->t_pid]);
++		}
++
++	//
++		return result;
++	}
++
++	*returnval = child->t_pid;
++
++	return 0;
++}
++
++void
++enter_process(void *tf,unsigned long addr)
++{
++	struct trapframe *childframe,child_tf;
++	struct addrspace *childspace;
++	if(tf!=NULL)
++	{
++
++		tf = (struct trapframe *) tf;
++		childframe = tf;
++		//copy the trapframe info now into the child_tf
++
++
++	//	child_tf = *childframe;
++
++		memcpy(&child_tf,tf,sizeof(struct trapframe));
++
++		child_tf.tf_a3=0;
++		child_tf.tf_v0=0;
++
++		child_tf.tf_epc +=4;
++
++
++		pid_t parentid = (pid_t)addr;
++		if(process_array[curthread->t_pid]->parent_id!=parentid)
++			process_array[curthread->t_pid]->parent_id=parentid;
++
++		if(!(curthread->t_addrspace==NULL))
++		{
++			childspace = curthread->t_addrspace;
++			as_activate(childspace);
++		}
++		mips_usermode(&child_tf);
++	}
++}
++
++
++int
++sys___execv(userptr_t p_name,userptr_t ar)
++{
++	struct vnode *p_vnode;
++	vaddr_t entrypoint, stackptr;
++
++	int result;
++	int counter;
++	size_t copied_length;
++
++	char *kname; // name of the program copied in kernel
++//	char *pname; //	name of pname
++
++//	pname = (char *) p_name;
++
++/*
++	if(p_name==NULL)
++		return EFAULT;
++
++	if(ar==NULL)
++		return EFAULT;
++
++	if(pname == '\0')
++		return ENOEXEC;
++*/
++
++	kname = (char *) kmalloc(sizeof(p_name));
++	if(kname==NULL)
++		return ENOMEM;
++
++//	result = copyin(p_name,kname,sizeof(p_name));
++	result = copyinstr(p_name,kname,sizeof(p_name),&copied_length);
++	if(result)
++	{
++
++		kfree(kname);
++		return result;
++	}
++
++/*
++	if(copied_length == 1)
++	{
++		kfree(kname);
++		return EINVAL;
++	}
++*/
++
++	//Copy into the kernel buffer
++	char **user_args = (char **) ar;
++
++	char **kernel_buffer = kmalloc(sizeof(char *));;
++	if(kernel_buffer==NULL)
++	{
++		kfree(kname);
++		return ENOMEM;
++	}
++
++	counter =0;
++	while(user_args[counter] != NULL)
++	{
++		char *temp = user_args[counter];
++
++		result = copyinstr((const_userptr_t)temp,kernel_buffer[counter],sizeof(temp),&copied_length);
++		if(result)
++		{
++			kfree(kname);
++			kfree(kernel_buffer);
++			return result;
++		}
++		counter++;
++
++	}
++
++	/* Open the file. */
++	result = vfs_open(kname, O_RDONLY, 0, &p_vnode);
++	if (result) {
++		return result;
++	}
++
++	/* We should be a new thread. */
++	KASSERT(curthread->t_addrspace == NULL);
++
++	/* Create a new address space. */
++	curthread->t_addrspace = as_create();
++	if (curthread->t_addrspace==NULL) {
++		vfs_close(p_vnode);
++		return ENOMEM;
++	}
++
++	/* Activate it. */
++	as_activate(curthread->t_addrspace);
++
++	/* Load the executable. */
++	result = load_elf(p_vnode, &entrypoint);
++	if (result) {
++		/* thread_exit destroys curthread->t_addrspace */
++		vfs_close(p_vnode);
++		return result;
++	}
++
++	/* Done with the file now. */
++	vfs_close(p_vnode);
++
++	/* Define the user stack in the address space */
++	result = as_define_stack(curthread->t_addrspace, &stackptr);
++	if (result) {
++		/* thread_exit destroys curthread->t_addrspace */
++		return result;
++	}
++
++
++	return 0;
++}
++
++
+diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
+index a6f45c8..a2ada5e 100644
+--- a/kern/syscall/runprogram.c
++++ b/kern/syscall/runprogram.c
+@@ -44,20 +44,109 @@
+ #include <vfs.h>
+ #include <syscall.h>
+ #include <test.h>
++#include <file_syscall.h>
+ 
++#include <copyinout.h>
+ /*
++ *
+  * Load program "progname" and start running it in usermode.
+  * Does not return except on error.
+  *
+  * Calls vfs_open on progname and thus may destroy it.
+  */
+ int
+-runprogram(char *progname)
++runprogram(char *progname,char **argss)
+ {
+ 	struct vnode *v;
+ 	vaddr_t entrypoint, stackptr;
+ 	int result;
+ 
++	if(argss==NULL)
++	{
++		//Do Nothing
++
++	}
++	else
++	{
++		char **user_args;
++		user_args = kmalloc(sizeof(char **));
++
++		user_args[0]=argss[0];
++
++	}
++/*
++
++	*
++	 * Author:Pratham Malik
++	 * adding arguments to stack
++
++	int counter;
++	char **user_args;
++	char *temp;
++	char *final;
++	int string_length;
++	int new_length;
++	int i;
++
++	counter=0;
++	string_length=0;
++
++
++	user_args = kmalloc(sizeof(char **));
++
++	while(argss[counter] != NULL)
++	{
++		temp = kstrdup(argss[counter]);
++		kprintf("The argument is %s",temp);
++
++		string_length = strlen(temp);
++		if((string_length) % 4 == 0)
++		{
++			user_args[counter] = kmalloc(sizeof(string_length));
++//			result= copyout(temp,(userptr_t) user_args[counter],sizeof(string_length));
++//			if(result)
++//				return result;
++
++			user_args[counter] = temp;
++		}
++		else
++		{
++
++			new_length = string_length;
++			while(new_length%4 !=0)
++			{
++				new_length++;
++			}
++
++			final=temp;
++
++			for(i=string_length;i<=new_length;i++)
++			{
++				final[i]= '\0';
++			}
++
++			user_args[counter] = kmalloc(sizeof(new_length));
++			user_args[counter] = final;
++//			result = copyout(final,(userptr_t) user_args[counter],sizeof(new_length));
++				if(result)
++					return result;
++
++
++		}
++		counter++;
++	}
++
++
++	char **userspacearg = kmalloc(sizeof(user_args));
++	result = copyout(user_args,(userptr_t) userspacearg,sizeof(userspacearg));
++	if(result)
++		return result;
++
++
++	//End of additions by PM
++
++
++*/
+ 	/* Open the file. */
+ 	result = vfs_open(progname, O_RDONLY, 0, &v);
+ 	if (result) {
+@@ -74,6 +163,7 @@ runprogram(char *progname)
+ 		return ENOMEM;
+ 	}
+ 
++
+ 	/* Activate it. */
+ 	as_activate(curthread->t_addrspace);
+ 
+@@ -95,12 +185,32 @@ runprogram(char *progname)
+ 		return result;
+ 	}
+ 
++
++
++
++/**
++ * Author: Mohit Arora
++ * Initialing the file table
++ */
++	int result1=100;
++	kprintf("Inside run program");
++	result1= intialize_file_desc_tbl(curthread->file_table);
++	if( intialize_file_desc_tbl(curthread->file_table)){
++		kprintf("Error");
++		return result1;
++	}
++
++//End of Additions by MA
++
+ 	/* Warp to user mode. */
+ 	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
+ 			  stackptr, entrypoint);
+ 	
++
+ 	/* enter_new_process does not return. */
+ 	panic("enter_new_process returned\n");
+ 	return EINVAL;
+ }
+ 
++
++
+diff --git a/kern/thread/synch.c b/kern/thread/synch.c
+index 9a7468c..f27b083 100644
+--- a/kern/thread/synch.c
++++ b/kern/thread/synch.c
+@@ -40,6 +40,7 @@
+ #include <current.h>
+ #include <synch.h>
+ 
++
+ ////////////////////////////////////////////////////////////
+ //
+ // Semaphore.
+@@ -87,8 +88,7 @@ sem_destroy(struct semaphore *sem)
+         kfree(sem);
+ }
+ 
+-void 
+-P(struct semaphore *sem)
++void P(struct semaphore *sem)
+ {
+         KASSERT(sem != NULL);
+ 
+@@ -150,6 +150,9 @@ V(struct semaphore *sem)
+ struct lock *
+ lock_create(const char *name)
+ {
++
++	DEBUG(DB_THREADS,
++							      "Inside Lock_create");
+         struct lock *lock;
+ 
+         lock = kmalloc(sizeof(struct lock));
+@@ -164,7 +167,18 @@ lock_create(const char *name)
+         }
+         
+         // add stuff here as needed
+-        
++        lock->lock_wchan = wchan_create(lock->lk_name);
++        	if (lock->lock_wchan == NULL) {
++        		kfree(lock->lk_name);
++        		kfree(lock);
++        		return NULL;
++        	}
++        spinlock_init(&lock->lk_spinlock);
++        lock->lock_hold=0;
++        lock->lk_thread= NULL;
++
++        DEBUG(DB_THREADS,
++        				"Exiting lock_create");
+         return lock;
+ }
+ 
+@@ -174,7 +188,8 @@ lock_destroy(struct lock *lock)
+         KASSERT(lock != NULL);
+ 
+         // add stuff here as needed
+-        
++        wchan_destroy(lock->lock_wchan);
++        spinlock_cleanup(&lock->lk_spinlock);
+         kfree(lock->lk_name);
+         kfree(lock);
+ }
+@@ -183,26 +198,81 @@ void
+ lock_acquire(struct lock *lock)
+ {
+         // Write this
++	DEBUG(DB_THREADS,
++	        				"Inside lock_acquire");
++	struct thread *mythread;
++	KASSERT(lock != NULL);
++    KASSERT(curthread->t_in_interrupt == false);
++
++	spinlock_acquire(&lock->lk_spinlock);
++
++	while(lock->lock_hold==1){
++		wchan_lock(lock->lock_wchan);
++		spinlock_release(&lock->lk_spinlock);
++		wchan_sleep(lock->lock_wchan);
++		spinlock_acquire(&lock->lk_spinlock);
++	}
++/*	else if(lock->lock_hold==0){
++		if (CURCPU_EXISTS()) {
++				mythread = curthread;
++				if (lock->lk_thread == mythread) {
++					panic("Deadlock on thread %p\n", lock);
++				}
++			}
++			else {
++				mythread = NULL;
++			} */
++
++	if(curthread!= NULL){
++				 mythread = curthread;
++				 lock->lk_thread = mythread;
++	}
++	lock->lock_hold= 1;
++
++	spinlock_release(&lock->lk_spinlock);
+ 
+-        (void)lock;  // suppress warning until code gets written
++	  //KASSERT(lock->lock_count > 0);
++
++       //(void)lock;  // suppress warning until code gets written
++	DEBUG(DB_THREADS,
++	        				"Exiting lock_acquire");
+ }
+ 
+ void
+ lock_release(struct lock *lock)
+ {
+         // Write this
++    KASSERT(lock != NULL);
++    spinlock_acquire(&lock->lk_spinlock);
++
++    lock->lock_hold=0;
++    KASSERT(lock->lock_hold== 0);
++    lock->lk_thread= NULL;
++    wchan_wakeone(lock->lock_wchan);
+ 
+-        (void)lock;  // suppress warning until code gets written
++    spinlock_release(&lock->lk_spinlock);
++       // (void)lock;  // suppress warning until code gets written
+ }
+ 
+ bool
+ lock_do_i_hold(struct lock *lock)
+ {
+         // Write this
+-
+-        (void)lock;  // suppress warning until code gets written
+-
+-        return true; // dummy until code gets written
++	if (!CURCPU_EXISTS()) {
++			return true;
++		}
++//	if(lock->lk_holder== curcpu->c_self){
++//		return true;
++//	}
++	//KASSERT(lock->lk_thread != NULL);
++	//KASSERT(lock != NULL);
++	bool value= false;
++
++        //(void)lock;  // suppress warning until code gets written
++	spinlock_acquire(&lock->lk_spinlock);
++        value= (lock->lk_thread== curthread); // dummy until code gets written
++        spinlock_release(&lock->lk_spinlock);
++        return value;
+ }
+ 
+ ////////////////////////////////////////////////////////////
+@@ -227,7 +297,20 @@ cv_create(const char *name)
+         }
+         
+         // add stuff here as needed
+-        
++        /*
++         * @Author: Student
++         * Implementing Condition Variable by defining the name
++         * and initializing the wait channel
++         */
++
++        cv->cv_wchan= wchan_create(cv->cv_name);
++		if (cv->cv_wchan == NULL) {
++			kfree(cv->cv_name);
++			kfree(cv);
++			return NULL;
++		}
++
++
+         return cv;
+ }
+ 
+@@ -246,22 +329,147 @@ void
+ cv_wait(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-        (void)cv;    // suppress warning until code gets written
+-        (void)lock;  // suppress warning until code gets written
++//        (void)cv;    // suppress warning until code gets written
++  //      (void)lock;  // suppress warning until code gets written
++
++        /*
++         * Author: Student
++         */
++        if(lock_do_i_hold(lock)) {
++        
++		wchan_lock(cv->cv_wchan);
++		//Release the supplied lock
++		lock_release(lock);
++			wchan_sleep(cv->cv_wchan);
++
++		lock_acquire(lock);
++				
++        }
+ }
+ 
+ void
+ cv_signal(struct cv *cv, struct lock *lock)
+ {
+         // Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++//	(void)cv;    // suppress warning until code gets written
++//	(void)lock;  // suppress warning until code gets written
++
++	/*
++	 * Author: Student
++	 * Wake up the wchan which is sleeping on the CV
++	 */
++	if(lock_do_i_hold(lock))
++	{
++		wchan_wakeone(cv->cv_wchan);
++	}
+ }
+ 
+ void
+ cv_broadcast(struct cv *cv, struct lock *lock)
+ {
+ 	// Write this
+-	(void)cv;    // suppress warning until code gets written
+-	(void)lock;  // suppress warning until code gets written
++//	(void)cv;    // suppress warning until code gets written
++//	(void)lock;  // suppress warning until code gets written
++	if(lock_do_i_hold(lock)) {
++	wchan_wakeall(cv->cv_wchan);
++	}
+ }
++///////////////////////////////////////////////
++//RW Locks
++
++
++struct rwlock *
++rwlock_create(const char *name)
++{
++	struct rwlock *rw;
++
++	rw = kmalloc(sizeof(rw));
++	if(rw==NULL){
++		return NULL;
++	}
++
++	rw->rwlock_name=kstrdup(name);
++	if(rw->rwlock_name==NULL){
++		kfree(rw);
++		return NULL;
++	}
++
++
++	//Create Semaphore
++	rw->rwlock_semaphore = sem_create(rw->rwlock_name,MAX_READ);
++	if (rw->rwlock_semaphore == NULL) {
++			kfree(rw->rwlock_name);
++			kfree(rw);
++			return NULL;
++	}
++	//rw->read_count=0;
++	//Create Lock
++	rw->rwlock_lock=lock_create(rw->rwlock_name);
++   	if (rw->rwlock_lock == NULL) {
++   		kfree(rw->rwlock_name);
++   		kfree(rw);
++	    return NULL;
++	}
++
++	return rw;
++}
++
++void
++rwlock_destroy(struct rwlock *rw_lock)
++{
++	KASSERT(rw_lock != NULL);
++
++	        // add stuff here as needed
++		sem_destroy(rw_lock->rwlock_semaphore);
++		lock_destroy(rw_lock->rwlock_lock);
++	    kfree(rw_lock->rwlock_name);
++	    kfree(rw_lock);
++}
++void
++rwlock_acquire_read(struct rwlock *rw_lock)
++{
++	lock_acquire(rw_lock->rwlock_lock);
++
++	P(rw_lock->rwlock_semaphore);
++	//rw_lock->read_count++;
++
++	lock_release(rw_lock->rwlock_lock);
++}
++
++void
++rwlock_release_read(struct rwlock *rw_lock){
++
++	V(rw_lock->rwlock_semaphore);
++	//rw_lock->read_count--;
++}
++
++void
++rwlock_acquire_write(struct rwlock *rw_lock){
++
++	lock_acquire(rw_lock->rwlock_lock);
++
++	while(1)
++	{
++		if(rw_lock->rwlock_semaphore->sem_count!=MAX_READ)
++			continue;
++		else if(rw_lock->rwlock_semaphore->sem_count==MAX_READ)
++		{
++			rw_lock->rwlock_semaphore->sem_count=1;
++			P(rw_lock->rwlock_semaphore);
++			break;
++		}
++	}
++
++	lock_release(rw_lock->rwlock_lock);
++}
++
++void
++rwlock_release_write(struct rwlock *rw_lock){
++
++	rw_lock->rwlock_semaphore->sem_count=MAX_READ-1;
++	V(rw_lock->rwlock_semaphore);
++
++
++}
++
++
+diff --git a/kern/thread/thread.c b/kern/thread/thread.c
+index e7235e3..af81457 100644
+--- a/kern/thread/thread.c
++++ b/kern/thread/thread.c
+@@ -47,9 +47,32 @@
+ #include <addrspace.h>
+ #include <mainbus.h>
+ #include <vnode.h>
++/* Added for file table size*/
++
++/**
++ * Author: Pratham Malik
++ */
++#include <psyscall.h>
++struct process_control *process_array[PROCESS_MAX];
++struct lock *pid_lock;
++
++//End of Additions by PM
++
++
+ 
+ #include "opt-synchprobs.h"
+ #include "opt-defaultscheduler.h"
++/*
++ * Author: Pratham Malik
++ * Added header file for process syscalls
++ */
++//#include <psyscall.h>
++#include <limits.h>
++
++extern struct process_control *process_array[PROCESS_MAX];
++struct lock *pid_lock;
++
++//End of adding by Pratham Malik
+ 
+ 
+ /* Magic number used as a guard value on kernel thread stacks. */
+@@ -154,6 +177,28 @@ thread_create(const char *name)
+ 
+ 	/* If you add to struct thread, be sure to initialize here */
+ 
++	/*Added BY Mohit
++	 *started
++	 */
++	/*Ended*/
++
++	/**
++	 * Author: Pratham Malik
++	 * Initialize PID to the process
++	 */
++	pid_t processid;
++	processid = allocate_pid();
++	if(processid==-1)
++	{
++		kfree(thread);
++		return NULL;
++	}
++
++	initialize_pid(thread,processid);
++
++	//End of Additions by Pratham Malik
++
++
+ 	return thread;
+ }
+ 
+@@ -168,6 +213,8 @@ thread_create(const char *name)
+ struct cpu *
+ cpu_create(unsigned hardware_number)
+ {
++	DEBUG(DB_THREADS,
++					      "Inside cpu_create");
+ 	struct cpu *c;
+ 	int result;
+ 	char namebuf[16];
+@@ -223,6 +270,9 @@ cpu_create(unsigned hardware_number)
+ 
+ 	cpu_machdep_init(c);
+ 
++	DEBUG(DB_THREADS,
++					      "Leaving cpu_create");
++
+ 	return c;
+ }
+ 
+@@ -293,6 +343,8 @@ exorcise(void)
+ void
+ thread_panic(void)
+ {
++	DEBUG(DB_THREADS,
++					      "Inside thread_panic");
+ 	/*
+ 	 * Kill off other CPUs.
+ 	 *
+@@ -327,6 +379,8 @@ thread_panic(void)
+ 	 * might be needed. It may also be necessary to go through and
+ 	 * forcibly unlock all locks or the like...
+ 	 */
++	DEBUG(DB_THREADS,
++						      "Exiting thread_panic");
+ }
+ 
+ /*
+@@ -350,12 +404,30 @@ thread_shutdown(void)
+ void
+ thread_bootstrap(void)
+ {
++
+ 	struct cpu *bootcpu;
+ 	struct thread *bootthread;
+ 
++
++
+ 	cpuarray_init(&allcpus);
+ 
+ 	/*
++	 * Author:Pratham Malik
++	 * Initialize the structure for process to zero
++	*/
++	int count=0;
++	for(count=0;count<PROCESS_MAX;count++)
++	{
++		process_array[count]=0;
++	}
++
++	//Create the pid_lock
++	pid_lock = lock_create("pid_lock");
++	//End of Addition by PM
++
++
++	/*
+ 	 * Create the cpu structure for the bootup CPU, the one we're
+ 	 * currently running on. Assume the hardware number is 0; that
+ 	 * might be updated later by mainbus-type code. This also
+@@ -382,6 +454,8 @@ thread_bootstrap(void)
+ 	curcpu->c_curthread = curthread;
+ 
+ 	/* Done */
++
++
+ }
+ 
+ /*
+@@ -436,6 +510,7 @@ static
+ void
+ thread_make_runnable(struct thread *target, bool already_have_lock)
+ {
++
+ 	struct cpu *targetcpu;
+ 	bool isidle;
+ 
+@@ -483,6 +558,7 @@ thread_fork(const char *name,
+ 	    struct thread **ret)
+ {
+ 	struct thread *newthread;
++	struct addrspace *childspace;
+ 
+ 	newthread = thread_create(name);
+ 	if (newthread == NULL) {
+@@ -493,11 +569,46 @@ thread_fork(const char *name,
+ 	newthread->t_stack = kmalloc(STACK_SIZE);
+ 	if (newthread->t_stack == NULL) {
+ 		thread_destroy(newthread);
++	//	kfree(process_array[newthread->t_pid]);
+ 		return ENOMEM;
+ 	}
+ 	thread_checkstack_init(newthread);
+ 
+ 	/*
++	 * Author: Pratham Malik
++	 * Copy the addrspace for the child
++	 */
++	int result;
++
++	if(curthread->t_addrspace!=NULL)
++	{
++		/*childspace = kmalloc(sizeof(struct addrspace));
++		if(childspace == NULL)
++		{
++			kfree(process_array[newthread->t_pid]);
++			return ENOMEM;
++		}
++*/
++		result = as_copy(curthread->t_addrspace,&childspace);
++		if(result)
++		{
++			//kfree(process_array[newthread->t_pid]);
++			return result;
++
++		}
++
++//		memcpy(newthread->t_addrspace,childspace,sizeof(childspace));
++		newthread->t_addrspace = childspace;
++
++		if(newthread->t_addrspace==NULL)
++		{
++			//kfree(process_array[newthread->t_pid]);
++			return ENOMEM;
++		}
++	}
++	//End of additions by PM
++
++	/*
+ 	 * Now we clone various fields from the parent thread.
+ 	 */
+ 
+@@ -513,6 +624,34 @@ thread_fork(const char *name,
+ 		newthread->t_cwd = curthread->t_cwd;
+ 	}
+ 
++	/**
++	 * Author: Pratham Malik
++	 */
++
++	int counter=0;
++	for(counter=0;counter<__OPEN_MAX;counter++)
++	{
++		if(curthread->file_table[counter]!=0)
++		{
++			//newthread->file_table[counter]=kmalloc(sizeof(struct file_descriptor));
++			newthread->file_table[counter]=curthread->file_table[counter];
++			if(counter>2)
++				curthread->file_table[counter]->reference_count++;
++		}else
++		{
++			newthread->file_table[counter]=0;
++		}
++	}
++
++	//Also add the parent id to the process array entry for the new child
++	pid_t parent_id = curthread->t_pid;
++	pid_t child_id = newthread->t_pid;
++
++	process_array[child_id]->parent_id = parent_id;
++
++	//End by PM
++
++
+ 	/*
+ 	 * Because new threads come out holding the cpu runqueue lock
+ 	 * (see notes at bottom of thread_switch), we need to account
+@@ -523,8 +662,6 @@ thread_fork(const char *name,
+ 	/* Set up the switchframe so entrypoint() gets called */
+ 	switchframe_init(newthread, entrypoint, data1, data2);
+ 
+-	/* Lock the current cpu's run queue and make the new thread runnable */
+-	thread_make_runnable(newthread, false);
+ 
+ 	/*
+ 	 * Return new thread structure if it's wanted. Note that using
+@@ -536,6 +673,10 @@ thread_fork(const char *name,
+ 		*ret = newthread;
+ 	}
+ 
++	/*
\ No newline at end of file
diff --git a/typescript b/typescript
new file mode 100644
index 0000000..368336e
--- /dev/null
+++ b/typescript
@@ -0,0 +1,326 @@
+Script started on Thu 12 Feb 2015 10:11:02 PM EST
+]0;trinity@zion: ~/srctrinity@zion:~/src$ git status
+# On branch master
+# Your branch is ahead of 'origin/master' by 5 commits.
+#
+# Changes not staged for commit:
+#   (use "git add <file>..." to update what will be committed)
+#   (use "git checkout -- <file>..." to discard changes in working directory)
+#
+#	modified:   kern/startup/main.c
+#
+# Untracked files:
+#   (use "git add <file>..." to include in what will be committed)
+#
+#	typescript
+no changes added to commit (use "git add" and/or "git commit -a")
+]0;trinity@zion: ~/srctrinity@zion:~/src$ git diff
+[?1h=diff --git a/kern/startup/main.c b/kern/startup/main.c[m
+index 93635ee..3526bd6 100644[m
+--- a/kern/startup/main.c[m
++++ b/kern/startup/main.c[m
+@@ -30,7 +30,7 @@[m
+ /*[m
+  * Main.[m
+  */[m
+-[m
++// "Adding for git" marora3@buffalo.edu[m
+ [m
+ #include <types.h>[m
+ #include <kern/errno.h>[m
+[K[?1l>]0;trinity@zion: ~/srctrinity@zion:~/src$ git add .[Kkern/s
+startup/    synchprobs/ syscall/    
+]0;trinity@zion: ~/srctrinity@zion:~/src$ git add kern/startup/main.c
+]0;trinity@zion: ~/srctrinity@zion:~/src$ git commit -a -m "Added Commet[Knt [K"
+[master b7e0a0e] Added Comment
+ Committer: ops-class.org Student <trinity@zion.(none)>
+Your name and email address were configured automatically based
+on your username and hostname. Please check that they are accurate.
+You can suppress this message by setting them explicitly:
+
+    git config --global user.name "Your Name"
+    git config --global user.email you@example.com
+
+After doing this, you may fix the identity used for this commit with:
+
+    git commit --amend --reset-author
+
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+]0;trinity@zion: ~/srctrinity@zion:~/src$ git status
+# On branch master
+# Your branch is ahead of 'origin/master' by 6 commits.
+#
+# Untracked files:
+#   (use "git add <file>..." to include in what will be committed)
+#
+#	typescript
+nothing added to commit but untracked files present (use "git add" to track)
+]0;trinity@zion: ~/srctrinity@zion:~/src$ cd kern/compile/As[KSST1
+]0;trinity@zion: ~/src/kern/compile/ASST1trinity@zion:~/src/kern/compile/ASST1$ bmake depend
+bmake includelinks
+`includelinks' is up to date.
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -M ../../../common/libc/printf/__printf.c ../../../common/libc/printf/snprintf.c ../../../common/libc/stdlib/atoi.c ../../../common/libc/string/bzero.c ../../../common/libc/string/memcpy.c ../../../common/libc/string/memmove.c ../../../common/libc/string/strcat.c ../../../common/libc/string/strchr.c ../../../common/libc/string/strcmp.c ../../../common/libc/string/strcpy.c ../../../common/libc/string/strlen.c ../../../common/libc/string/strrchr.c ../../../common/libc/string/strtok_r.c ../../compile/ASST1/autoconf.c ../../dev/generic/beep.c ../../dev/generic/console.c ../../dev/generic/random.c ../../dev/generic/rtclock.c ../../dev/lamebus/beep_ltimer.c ../../dev/lamebus/con_lser.c ../../dev/lamebus/emu_att.c ../../dev/lamebus/emu.c ../../dev/lamebus/lamebus.c ../../dev/lamebus/lhd_att.c ../../dev/lamebus/lhd.c ../../dev/lamebus/lrandom_att.c ../../dev/lamebus/lrandom.c ../../dev/lamebus/lser_att.c ../../dev/lamebus/lser.c ../../dev/lamebus/ltimer_att.c ../../dev/lamebus/ltimer.c ../../dev/lamebus/ltrace_att.c ../../dev/lamebus/ltrace.c ../../dev/lamebus/random_lrandom.c ../../dev/lamebus/rtclock_ltimer.c ../../fs/sfs/sfs_fs.c ../../fs/sfs/sfs_io.c ../../fs/sfs/sfs_vnode.c ../../lib/array.c ../../lib/bitmap.c ../../lib/bswap.c ../../lib/kgets.c ../../lib/kprintf.c ../../lib/misc.c ../../lib/uio.c ../../startup/main.c ../../startup/menu.c ../../synchprobs/drivers.c ../../synchprobs/problems.c ../../syscall/loadelf.c ../../syscall/runprogram.c ../../syscall/time_syscalls.c ../../test/arraytest.c ../../test/bitmaptest.c ../../test/fstest.c ../../test/malloctest.c ../../test/synchtest.c ../../test/threadtest.c ../../test/tt3.c ../../thread/clock.c ../../thread/spinlock.c ../../thread/spl.c ../../thread/synch.c ../../thread/thread.c ../../thread/threadlist.c ../../vfs/device.c ../../vfs/devnull.c ../../vfs/vfscwd.c ../../vfs/vfslist.c ../../vfs/vfslookup.c ../../vfs/vfspath.c ../../vfs/vnode.c ../../vm/kmalloc.c ../../arch/mips/locore/trap.c ../../arch/mips/syscall/syscall.c ../../arch/mips/thread/cpu.c ../../arch/mips/thread/switchframe.c ../../arch/mips/thread/switch.S ../../arch/mips/thread/thread_machdep.c ../../arch/mips/thread/threadstart.S ../../arch/mips/vm/dumbvm.c ../../arch/mips/vm/ram.c ../../../common/gcc-millicode/adddi3.c ../../../common/gcc-millicode/anddi3.c ../../../common/gcc-millicode/ashldi3.c ../../../common/gcc-millicode/ashrdi3.c ../../../common/gcc-millicode/cmpdi2.c ../../../common/gcc-millicode/divdi3.c ../../../common/gcc-millicode/iordi3.c ../../../common/gcc-millicode/lshldi3.c ../../../common/gcc-millicode/lshrdi3.c ../../../common/gcc-millicode/moddi3.c ../../../common/gcc-millicode/muldi3.c ../../../common/gcc-millicode/negdi2.c ../../../common/gcc-millicode/notdi2.c ../../../common/gcc-millicode/qdivrem.c ../../../common/gcc-millicode/subdi3.c ../../../common/gcc-millicode/ucmpdi2.c ../../../common/gcc-millicode/udivdi3.c ../../../common/gcc-millicode/umoddi3.c ../../../common/gcc-millicode/xordi3.c ../../../common/libc/arch/mips/setjmp.S ../../vm/copyinout.c ../../arch/mips/locore/cache-mips161.S ../../arch/mips/locore/exception-mips1.S ../../arch/mips/vm/tlb-mips1.S ../../arch/sys161/dev/lamebus_machdep.c ../../arch/sys161/startup/start.S > .depend
+]0;trinity@zion: ~/src/kern/compile/ASST1trinity@zion:~/src/kern/compile/ASST1$ bmake
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../startup/main.c
+../../startup/main.c:2: error: expected declaration specifiers or '...' before string constant
+../../startup/main.c:2: error: expected declaration specifiers or '...' before 'harvard_copyright'
+cc1: warnings being treated as errors
+../../startup/main.c:2: warning: data definition has no type or storage class
+../../startup/main.c:2: warning: type defaults to 'int' in declaration of 'kprintf'
+../../startup/main.c:3: error: expected declaration specifiers or '...' before string constant
+../../startup/main.c:3: warning: data definition has no type or storage class
+../../startup/main.c:3: warning: type defaults to 'int' in declaration of 'kprintf'
+../../startup/main.c:5: error: expected declaration specifiers or '...' before string constant
+../../startup/main.c:6: error: expected declaration specifiers or '...' before 'GROUP_VERSION'
+../../startup/main.c:6: error: expected declaration specifiers or '...' before 'buildconfig'
+../../startup/main.c:6: error: expected declaration specifiers or '...' before 'buildversion'
+../../startup/main.c:6: warning: data definition has no type or storage class
+../../startup/main.c:6: warning: type defaults to 'int' in declaration of 'kprintf'
+../../startup/main.c:7: error: expected declaration specifiers or '...' before string constant
+../../startup/main.c:7: warning: data definition has no type or storage class
+../../startup/main.c:7: warning: type defaults to 'int' in declaration of 'kprintf'
+../../startup/main.c:10: warning: data definition has no type or storage class
+../../startup/main.c:10: warning: type defaults to 'int' in declaration of 'ram_bootstrap'
+../../startup/main.c:11: warning: data definition has no type or storage class
+../../startup/main.c:11: warning: type defaults to 'int' in declaration of 'thread_bootstrap'
+../../startup/main.c:12: warning: data definition has no type or storage class
+../../startup/main.c:12: warning: type defaults to 'int' in declaration of 'hardclock_bootstrap'
+../../startup/main.c:13: warning: data definition has no type or storage class
+../../startup/main.c:13: warning: type defaults to 'int' in declaration of 'vfs_bootstrap'
+../../startup/main.c:16: error: expected declaration specifiers or '...' before string constant
+../../startup/main.c:16: warning: data definition has no type or storage class
+../../startup/main.c:16: warning: type defaults to 'int' in declaration of 'kprintf'
+../../startup/main.c:17: error: expected ')' before '->' token
+../../startup/main.c:18: warning: data definition has no type or storage class
+../../startup/main.c:18: warning: type defaults to 'int' in declaration of 'mainbus_bootstrap'
+../../startup/main.c:19: error: expected ')' before '->' token
+../../startup/main.c:21: warning: data definition has no type or storage class
+../../startup/main.c:21: warning: type defaults to 'int' in declaration of 'pseudoconfig'
+../../startup/main.c:22: error: expected declaration specifiers or '...' before string constant
+../../startup/main.c:22: warning: data definition has no type or storage class
+../../startup/main.c:22: warning: type defaults to 'int' in declaration of 'kprintf'
+../../startup/main.c:25: warning: data definition has no type or storage class
+../../startup/main.c:25: warning: type defaults to 'int' in declaration of 'vm_bootstrap'
+../../startup/main.c:26: warning: data definition has no type or storage class
+../../startup/main.c:26: warning: type defaults to 'int' in declaration of 'kprintf_bootstrap'
+../../startup/main.c:27: warning: data definition has no type or storage class
+../../startup/main.c:27: warning: type defaults to 'int' in declaration of 'thread_start_cpus'
+../../startup/main.c:30: error: expected declaration specifiers or '...' before string constant
+../../startup/main.c:30: warning: data definition has no type or storage class
+../../startup/main.c:30: warning: type defaults to 'int' in declaration of 'vfs_setbootfs'
+../../startup/main.c:36: error: expected declaration specifiers or '...' before 'sizeof'
+../../startup/main.c:36: warning: data definition has no type or storage class
+../../startup/main.c:36: warning: type defaults to 'int' in declaration of 'COMPILE_ASSERT'
+../../startup/main.c:37: error: expected declaration specifiers or '...' before 'sizeof'
+../../startup/main.c:37: warning: data definition has no type or storage class
+../../startup/main.c:37: warning: type defaults to 'int' in declaration of 'COMPILE_ASSERT'
+../../startup/main.c:38: error: expected identifier or '(' before '}' token
+../../startup/main.c: In function 'shutdown':
+../../startup/main.c:50: warning: implicit declaration of function 'vfs_clearbootfs'
+../../startup/main.c:51: warning: implicit declaration of function 'vfs_clearcurdir'
+../../startup/main.c:52: warning: implicit declaration of function 'vfs_unmountall'
+../../startup/main.c:54: warning: implicit declaration of function 'thread_shutdown'
+../../startup/main.c:56: warning: implicit declaration of function 'splhigh'
+../../startup/main.c: At top level:
+../../startup/main.c:70: warning: no previous prototype for 'sys_reboot'
+../../startup/main.c: In function 'sys_reboot':
+../../startup/main.c:72: error: 'RB_REBOOT' undeclared (first use in this function)
+../../startup/main.c:72: error: (Each undeclared identifier is reported only once
+../../startup/main.c:72: error: for each function it appears in.)
+../../startup/main.c:73: error: 'RB_HALT' undeclared (first use in this function)
+../../startup/main.c:74: error: 'RB_POWEROFF' undeclared (first use in this function)
+../../startup/main.c:77: error: 'EINVAL' undeclared (first use in this function)
+../../startup/main.c:85: warning: implicit declaration of function 'mainbus_halt'
+../../startup/main.c:89: warning: implicit declaration of function 'mainbus_reboot'
+../../startup/main.c:93: warning: implicit declaration of function 'mainbus_poweroff'
+../../startup/main.c:97: warning: implicit declaration of function 'panic'
+../../startup/main.c: At top level:
+../../startup/main.c:107: warning: no previous prototype for 'kmain'
+../../startup/main.c: In function 'kmain':
+../../startup/main.c:108: warning: implicit declaration of function 'boot'
+../../startup/main.c:110: warning: implicit declaration of function 'menu'
+*** Error code 1
+
+Stop.
+bmake: stopped in /home/trinity/src/kern/compile/ASST1
+]0;trinity@zion: ~/src/kern/compile/ASST1trinity@zion:~/src/kern/compile/ASST1$ cd
+]0;trinity@zion: ~trinity@zion:~$ cd src
+]0;trinity@zion: ~/srctrinity@zion:~/src$ git log
+[?1h=commit b7e0a0eab5642bfccad4729662009acf187bd2ad[m
+Author: ops-class.org Student <trinity@zion.(none)>[m
+Date:   Thu Feb 12 22:12:06 2015 -0500[m
+[m
+    Added Comment[m
+[m
+commit e5e511cc34501a99d73ccfbd10c192dfcea10fa8[m
+Author: ops-class.org Student <trinity@zion.(none)>[m
+Date:   Thu Feb 12 22:10:43 2015 -0500[m
+[m
+    Just like that[m
+[m
+commit c086f964f999c8a8f61eba95a3f36682eb90567d[m
+Author: ops-class.org Student <trinity@zion.(none)>[m
+Date:   Thu Feb 12 21:59:18 2015 -0500[m
+[m
+    Removed Comment[m
+[m
+commit 164bc96c376698e37e40e96321f25ae78f2c725d[m
+Author: ops-class.org Student <trinity@zion.(none)>[m
+Date:   Thu Feb 12 21:53:58 2015 -0500[m
+[m
+    Added Comment for GIT[m
+:[K[K[?1l>]0;trinity@zion: ~/srctrinity@zion:~/src$ git revert b7e0a0eab
+error: Your local changes to the following files would be overwritten by merge:
+	kern/startup/main.c
+Please, commit your changes or stash them before you can merge.
+Aborting
+]0;trinity@zion: ~/srctrinity@zion:~/src$ gir[Kt reset --hard b7e0a0eab
+HEAD is now at b7e0a0e Added Comment
+]0;trinity@zion: ~/srctrinity@zion:~/src$ cd kern/compile/Ass[K[Ks[KSST0
+]0;trinity@zion: ~/src/kern/compile/ASST0trinity@zion:~/src/kern/compile/ASST0$ bmnake[K[K[K[Kake depend
+bmake includelinks
+`includelinks' is up to date.
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -M ../../../common/libc/printf/__printf.c ../../../common/libc/printf/snprintf.c ../../../common/libc/stdlib/atoi.c ../../../common/libc/string/bzero.c ../../../common/libc/string/memcpy.c ../../../common/libc/string/memmove.c ../../../common/libc/string/strcat.c ../../../common/libc/string/strchr.c ../../../common/libc/string/strcmp.c ../../../common/libc/string/strcpy.c ../../../common/libc/string/strlen.c ../../../common/libc/string/strrchr.c ../../../common/libc/string/strtok_r.c ../../compile/ASST0/autoconf.c ../../dev/generic/beep.c ../../dev/generic/console.c ../../dev/generic/random.c ../../dev/generic/rtclock.c ../../dev/lamebus/beep_ltimer.c ../../dev/lamebus/con_lser.c ../../dev/lamebus/emu_att.c ../../dev/lamebus/emu.c ../../dev/lamebus/lamebus.c ../../dev/lamebus/lhd_att.c ../../dev/lamebus/lhd.c ../../dev/lamebus/lrandom_att.c ../../dev/lamebus/lrandom.c ../../dev/lamebus/lser_att.c ../../dev/lamebus/lser.c ../../dev/lamebus/ltimer_att.c ../../dev/lamebus/ltimer.c ../../dev/lamebus/ltrace_att.c ../../dev/lamebus/ltrace.c ../../dev/lamebus/random_lrandom.c ../../dev/lamebus/rtclock_ltimer.c ../../fs/sfs/sfs_fs.c ../../fs/sfs/sfs_io.c ../../fs/sfs/sfs_vnode.c ../../lib/array.c ../../lib/bitmap.c ../../lib/bswap.c ../../lib/kgets.c ../../lib/kprintf.c ../../lib/misc.c ../../lib/uio.c ../../startup/main.c ../../startup/menu.c ../../syscall/loadelf.c ../../syscall/runprogram.c ../../syscall/time_syscalls.c ../../test/arraytest.c ../../test/bitmaptest.c ../../test/fstest.c ../../test/malloctest.c ../../test/synchtest.c ../../test/threadtest.c ../../test/tt3.c ../../thread/clock.c ../../thread/spinlock.c ../../thread/spl.c ../../thread/synch.c ../../thread/thread.c ../../thread/threadlist.c ../../vfs/device.c ../../vfs/devnull.c ../../vfs/vfscwd.c ../../vfs/vfslist.c ../../vfs/vfslookup.c ../../vfs/vfspath.c ../../vfs/vnode.c ../../vm/kmalloc.c ../../arch/mips/locore/trap.c ../../arch/mips/syscall/syscall.c ../../arch/mips/thread/cpu.c ../../arch/mips/thread/switchframe.c ../../arch/mips/thread/switch.S ../../arch/mips/thread/thread_machdep.c ../../arch/mips/thread/threadstart.S ../../arch/mips/vm/dumbvm.c ../../arch/mips/vm/ram.c ../../../common/gcc-millicode/adddi3.c ../../../common/gcc-millicode/anddi3.c ../../../common/gcc-millicode/ashldi3.c ../../../common/gcc-millicode/ashrdi3.c ../../../common/gcc-millicode/cmpdi2.c ../../../common/gcc-millicode/divdi3.c ../../../common/gcc-millicode/iordi3.c ../../../common/gcc-millicode/lshldi3.c ../../../common/gcc-millicode/lshrdi3.c ../../../common/gcc-millicode/moddi3.c ../../../common/gcc-millicode/muldi3.c ../../../common/gcc-millicode/negdi2.c ../../../common/gcc-millicode/notdi2.c ../../../common/gcc-millicode/qdivrem.c ../../../common/gcc-millicode/subdi3.c ../../../common/gcc-millicode/ucmpdi2.c ../../../common/gcc-millicode/udivdi3.c ../../../common/gcc-millicode/umoddi3.c ../../../common/gcc-millicode/xordi3.c ../../../common/libc/arch/mips/setjmp.S ../../vm/copyinout.c ../../arch/mips/locore/cache-mips161.S ../../arch/mips/locore/exception-mips1.S ../../arch/mips/vm/tlb-mips1.S ../../arch/sys161/dev/lamebus_machdep.c ../../arch/sys161/startup/start.S > .depend
+]0;trinity@zion: ~/src/kern/compile/ASST0trinity@zion:~/src/kern/compile/ASST0$ bmake
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../startup/main.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../test/fstest.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../test/malloctest.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../test/synchtest.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../test/threadtest.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../test/tt3.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../thread/clock.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../thread/spinlock.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../thread/spl.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../thread/synch.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../thread/thread.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../vfs/device.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../vfs/vfslist.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../vfs/vfslookup.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../vfs/vnode.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../arch/mips/locore/trap.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../arch/mips/thread/cpu.c
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c ../../arch/sys161/dev/lamebus_machdep.c
+../../conf/newvers.sh ASST0
+*** This is ASST0 build #9 ***
+mips-harvard-os161-gcc -g -Wall -W -Wwrite-strings -Wmissing-prototypes -Werror -std=gnu99 -mno-abicalls -fno-pic -ffixed-23 -nostdinc -I../../include -I../../dev -I. -Iincludelinks -ffreestanding -D_KERNEL -c vers.c
+mips-harvard-os161-ld   -nostdlib -T ../../arch/mips/conf/ldscript __printf.o snprintf.o atoi.o bzero.o memcpy.o memmove.o strcat.o strchr.o strcmp.o strcpy.o strlen.o strrchr.o strtok_r.o autoconf.o beep.o console.o random.o rtclock.o beep_ltimer.o con_lser.o emu_att.o emu.o lamebus.o lhd_att.o lhd.o lrandom_att.o lrandom.o lser_att.o lser.o ltimer_att.o ltimer.o ltrace_att.o ltrace.o random_lrandom.o rtclock_ltimer.o sfs_fs.o sfs_io.o sfs_vnode.o array.o bitmap.o bswap.o kgets.o kprintf.o misc.o uio.o main.o menu.o loadelf.o runprogram.o time_syscalls.o arraytest.o bitmaptest.o fstest.o malloctest.o synchtest.o threadtest.o tt3.o clock.o spinlock.o spl.o synch.o thread.o threadlist.o device.o devnull.o vfscwd.o vfslist.o vfslookup.o vfspath.o vnode.o kmalloc.o trap.o syscall.o cpu.o switchframe.o switch.o thread_machdep.o threadstart.o dumbvm.o ram.o adddi3.o anddi3.o ashldi3.o ashrdi3.o cmpdi2.o divdi3.o iordi3.o lshldi3.o lshrdi3.o moddi3.o muldi3.o negdi2.o notdi2.o qdivrem.o subdi3.o ucmpdi2.o udivdi3.o umoddi3.o xordi3.o setjmp.o copyinout.o cache-mips161.o exception-mips1.o tlb-mips1.o lamebus_machdep.o start.o vers.o -o kernel
+mips-harvard-os161-size kernel
+   text	   data	    bss	    dec	    hex	filename
+ 184984	    448	   7788	 193220	  2f2c4	kernel
+]0;trinity@zion: ~/src/kern/compile/ASST0trinity@zion:~/src/kern/compile/ASST0$ cd
+]0;trinity@zion: ~trinity@zion:~$ cd src
+]0;trinity@zion: ~/srctrinity@zion:~/src$ git diff
+[?1h=diff --git a/kern/thread/synch.c b/kern/thread/synch.c[m
+index cb76b9a..0651f16 100644[m
+--- a/kern/thread/synch.c[m
++++ b/kern/thread/synch.c[m
+@@ -150,6 +150,9 @@ V(struct semaphore *sem)[m
+ struct lock *[m
+ lock_create(const char *name)[m
+ {[m
++[m
++       DEBUG(DB_THREADS,[m
++                                                             "Inside Lock_creat[m
+         struct lock *lock;[m
+ [m
+         lock = kmalloc(sizeof(struct lock));[m
+@@ -173,6 +176,9 @@ lock_create(const char *name)[m
+         spinlock_init(&lock->lk_spinlock);[m
+         lock->lock_hold=0;[m
+         lock->lk_thread= NULL;[m
++[m
++        DEBUG(DB_THREADS,[m
++                                       "Exiting lock_create");[m
+         return lock;[m
+ }[m
+:[K[K [m
+:[K[K@@ -192,6 +198,8 @@ void[m
+:[K[K lock_acquire(struct lock *lock)[m
+:[K[K {[m
+:[K[K         // Write this[m
+:[K[K+       DEBUG(DB_THREADS,[m
+:[K[K+                                               "Inside lock_acquire");[m
+:[K[K        struct thread *mythread;[m
+:[K[K        KASSERT(lock != NULL);[m
+:[K[K     KASSERT(curthread->t_in_interrupt == false);[m
+:[K[K@@ -226,6 +234,8 @@ lock_acquire(struct lock *lock)[m
+:[K[K          //KASSERT(lock->lock_count > 0);[m
+:[K[K [m
+:[K[K        //(void)lock;  // suppress warning until code gets written[m
+:[K[K+       DEBUG(DB_THREADS,[m
+:[K[K+                                               "Exiting lock_acquire");[m
+:[K[K }[m
+:[K[K [m
+:[K[K void[m
+:[K[Kdiff --git a/kern/thread/thread.c b/kern/thread/thread.c[m
+:[K[Kindex e7235e3..bd6cbbb 100644[m
+:[K[K--- a/kern/thread/thread.c[m
+:[K[K+++ b/kern/thread/thread.c[m
+:[K[K@@ -168,6 +168,8 @@ thread_create(const char *name)[m
+:[K[K struct cpu *[m
+:[K[K cpu_create(unsigned hardware_number)[m
+:[K[K {[m
+:[K[K+       DEBUG(DB_THREADS,[m
+:[K[K+                                             "Inside cpu_create");[m
+:[K[K        struct cpu *c;[m
+:[K[K        int result;[m
+:[K[K        char namebuf[16];[m
+:[K[K@@ -223,6 +225,9 @@ cpu_create(unsigned hardware_number)[m
+:[K[K [m
+:[K[K        cpu_machdep_init(c);[m
+:[K[K [m
+:[K[K+       DEBUG(DB_THREADS,[m
+:[K[K+                                             "Leaving cpu_create");[m
+:[K[K+[m
+:[K[K        return c;[m
+:[K[K }[m
+:[K[K [m
+:[K[K@@ -293,6 +298,8 @@ exorcise(void)[m
+:[K[K void[m
+:[K[K thread_panic(void)[m
+:[K[K {[m
+:[K[K+       DEBUG(DB_THREADS,[m
+:[K[K+                                             "Inside thread_panic");[m
+:[K[K        /*[m
+:[K[K         * Kill off other CPUs.[m
+:[K[K         *[m
+:[K[K@@ -327,6 +334,8 @@ thread_panic(void)[m
+:[K[K         * might be needed. It may also be necessary to go through and[m
+:[K[K         * forcibly unlock all locks or the like...[m
+:[K[K         */[m
+:[K[K+       DEBUG(DB_THREADS,[m
+:[K[K+                                                     "Exiting thread_panic");[m
+:[K[K }[m
+:[K[K [m
+:[K[K /*[m
+:[K[K@@ -436,6 +445,7 @@ static[m
+:[K[K void[m
+:[K[K thread_make_runnable(struct thread *target, bool already_have_lock)[m
+:[K[K {[m
+:[K[K+[m
+:[K[K        struct cpu *targetcpu;[m
+:[K[K        bool isidle;[m
+:[K[K [m
+:[K[K@@ -1070,7 +1080,8 @@ wchan_wakeone(struct wchan *wc)[m
+:[K[K                /* Nobody was sleeping. */[m
+:[K[K                return;[m
+:[K[K        }[m
+:[K[K-[m
+:[K[K+       DEBUG(DB_THREADS,[m
+:[K[K+                                     "Waking thread UP");[m
+:[K[K        thread_make_runnable(target, false);[m
+:[K[K }[m
+:[K[K [m
+:[K[K@@ -1108,6 +1119,8 @@ wchan_wakeall(struct wchan *wc)[m
+:[K[K                thread_make_runnable(target, false);[m
+:[K[K        }[m
+:[K[K [m
+:[K[K+       DEBUG(DB_THREADS,[m
+:[K[K+                                             "Waking All threads UP");[m
+:[K[K        threadlist_cleanup(&list);[m
+:[K[K }[m
+:[K[K [m
+:[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[K[7m(END)[27m[K[K[?1l>]0;trinity@zion: ~/srctrinity@zion:~/src$ exit
+exit
+
+Script done on Thu 12 Feb 2015 10:29:24 PM EST
diff --git a/user/testbin/fileonlytest/fileonlytest.c b/user/testbin/fileonlytest/fileonlytest.c
index b807ff6..d756e52 100644
--- a/user/testbin/fileonlytest/fileonlytest.c
+++ b/user/testbin/fileonlytest/fileonlytest.c
@@ -160,6 +160,7 @@ main(int argc, char **argv)
 		
 	// 23 Mar 2012 : GWA : FIXME : Spin until exit() works.
 	
+	_exit(0);
 	printf("Spinning in case exit() doesn't work.\n");
 	while (1) {};
 
